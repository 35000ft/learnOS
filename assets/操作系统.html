<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; --title-bar-height:20px; }
.mac-os-11 { --title-bar-height:28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }


:root {
  --mermaid-theme: night;
}

[lang='mermaid'] .label {
  color: #333;
}

/* CSS Document */

/** code highlight */

.cm-s-inner .cm-variable,
.cm-s-inner .cm-operator,
.cm-s-inner .cm-property {
    color: #b8bfc6;
}

.cm-s-inner .cm-keyword {
    color: #C88FD0;
}

.cm-s-inner .cm-tag {
    color: #7DF46A;
}

.cm-s-inner .cm-attribute {
    color: #7575E4;
}

.CodeMirror div.CodeMirror-cursor {
    border-left: 1px solid #b8bfc6;
    z-index: 3;
}

.cm-s-inner .cm-string {
    color: #D26B6B;
}

.cm-s-inner .cm-comment,
.cm-s-inner.cm-comment {
    color: #DA924A;
}

.cm-s-inner .cm-header,
.cm-s-inner .cm-def,
.cm-s-inner.cm-header,
.cm-s-inner.cm-def {
    color: #8d8df0;
}

.cm-s-inner .cm-quote,
.cm-s-inner.cm-quote {
    color: #57ac57;
}

.cm-s-inner .cm-hr {
    color: #d8d5d5;
}

.cm-s-inner .cm-link {
    color: #d3d3ef;
}

.cm-s-inner .cm-negative {
    color: #d95050;
}

.cm-s-inner .cm-positive {
    color: #50e650;
}

.cm-s-inner .cm-string-2 {
    color: #f50;
}

.cm-s-inner .cm-meta,
.cm-s-inner .cm-qualifier {
    color: #b7b3b3;
}

.cm-s-inner .cm-builtin {
    color: #f3b3f8;
}

.cm-s-inner .cm-bracket {
    color: #997;
}

.cm-s-inner .cm-atom,
.cm-s-inner.cm-atom {
    color: #84B6CB;
}

.cm-s-inner .cm-number {
    color: #64AB8F;
}

.cm-s-inner .cm-variable {
    color: #b8bfc6;
}

.cm-s-inner .cm-variable-2 {
    color: #9FBAD5;
}

.cm-s-inner .cm-variable-3 {
    color: #1cc685;
}

.CodeMirror-selectedtext,
.CodeMirror-selected {
    background: #4a89dc;
    color: #fff !important;
    text-shadow: none;
}

.CodeMirror-gutters {
    border-right: none;
}

/* CSS Document */

/** markdown source **/
.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property
{
    color: #cebcca;
}

.CodeMirror.cm-s-typora-default div.CodeMirror-cursor{
    border-left: 3px solid #b8bfc6;
}

.cm-s-typora-default .cm-comment {
    color: #9FB1FF;
}

.cm-s-typora-default .cm-string {
    color: #A7A7D9
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
    color: #848695;
    font-style: italic;
}

.cm-s-typora-default .cm-link {
    color: #95B94B;
}

.cm-s-typora-default .CodeMirror-activeline-background {
    background: rgba(51, 51, 51, 0.72);
}

.cm-s-typora-default .cm-comment, .cm-s-typora-default .cm-code {
	color: #8aa1e1;
}@import "";
@import "";
@import "";

:root {
    --bg-color:  #363B40;
    --side-bar-bg-color: #2E3033;
    --text-color: #b8bfc6;

    --select-text-bg-color:#4a89dc;

    --item-hover-bg-color: #0a0d16;
    --control-text-color: #b7b7b7;
    --control-text-hover-color: #eee;
    --window-border: 1px solid #555;

    --active-file-bg-color: rgb(34, 34, 34);
    --active-file-border-color: #8d8df0;

    --primary-color: #a3d5fe;

    --active-file-text-color: white;
    --item-hover-bg-color: #70717d;
    --item-hover-text-color: white;
    --primary-color: #6dc1e7;

    --rawblock-edit-panel-bd: #333;

    --search-select-bg-color: #428bca;
}

html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
}

html,
body {
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    background: #363B40;
    background: var(--bg-color);
    fill: currentColor;
    line-height: 1.625rem;
}

#write {
    max-width: 914px;
}


@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

html,
body,
button,
input,
select,
textarea,
div.code-tooltip-content {
    color: #b8bfc6;
    border-color: transparent;
}

div.code-tooltip,
.md-hover-tip .md-arrow:after {
    background: #333;
}

.native-window #md-notification {
    border: 1px solid #70717d;
}

.popover.bottom > .arrow:after {
    border-bottom-color: #333;
}

html,
body,
button,
input,
select,
textarea {
    font-family: "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
}

hr {
    height: 2px;
    border: 0;
    margin: 24px 0 !important;
}

h1,
h2,
h3,
h4,
h5,
h6 {
    font-family: "Lucida Grande", "Corbel", sans-serif;
    font-weight: normal;
    clear: both;
    -ms-word-wrap: break-word;
    word-wrap: break-word;
    margin: 0;
    padding: 0;
    color: #DEDEDE
}

h1 {
    font-size: 2.5rem;
    /* 36px */
    line-height: 2.75rem;
    /* 40px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1.5px;
}

h2 {
    font-size: 1.63rem;
    /* 24px */
    line-height: 1.875rem;
    /* 30px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1px;
    font-weight: bold;
}

h3 {
    font-size: 1.17rem;
    /* 18px */
    line-height: 1.5rem;
    /* 24px */
    margin-bottom: 1.5rem;
    /* 24px */
    letter-spacing: -1px;
    font-weight: bold;
}

h4 {
    font-size: 1.12rem;
    /* 16px */
    line-height: 1.375rem;
    /* 22px */
    margin-bottom: 1.5rem;
    /* 24px */
    color: white;
}

h5 {
    font-size: 0.97rem;
    /* 16px */
    line-height: 1.25rem;
    /* 22px */
    margin-bottom: 1.5rem;
    /* 24px */
    font-weight: bold;
}

h6 {
    font-size: 0.93rem;
    /* 16px */
    line-height: 1rem;
    /* 16px */
    margin-bottom: 0.75rem;
    color: white;
}

@media (min-width: 980px) {
    h3.md-focus:before,
    h4.md-focus:before,
    h5.md-focus:before,
    h6.md-focus:before {
        color: #ddd;
        border: 1px solid #ddd;
        border-radius: 3px;
        position: absolute;
        left: -1.642857143rem;
        top: .357142857rem;
        float: left;
        font-size: 9px;
        padding-left: 2px;
        padding-right: 2px;
        vertical-align: bottom;
        font-weight: normal;
        line-height: normal;
    }

    h3.md-focus:before {
        content: 'h3';
    }

    h4.md-focus:before {
        content: 'h4';
    }

    h5.md-focus:before {
        content: 'h5';
        top: 0px;
    }

    h6.md-focus:before {
        content: 'h6';
        top: 0px;
    }
}

a {
    text-decoration: none;
    outline: 0;
}

a:hover {
    outline: 0;
}

a:focus {
    outline: thin dotted;
}

sup.md-footnote {
    background-color: #555;
    color: #ddd;
}

p {
    -ms-word-wrap: break-word;
    word-wrap: break-word;
}

p,
ul,
dd,
ol,
hr,
address,
pre,
table,
iframe,
.wp-caption,
.wp-audio-shortcode,
.wp-video-shortcode {
    margin-top: 0;
    margin-bottom: 1.5rem;
    /* 24px */
}

audio:not([controls]) {
    display: none;
}

[hidden] {
    display: none;
}

::-moz-selection {
    background: #4a89dc;
    color: #fff;
    text-shadow: none;
}

*.in-text-selection,
::selection {
    background: #4a89dc;
    color: #fff;
    text-shadow: none;
}

ul,
ol {
    padding: 0 0 0 1.875rem;
    /* 30px */
}

ul {
    list-style: square;
}

ol {
    list-style: decimal;
}

ul ul,
ol ol,
ul ol,
ol ul {
    margin: 0;
}

b,
th,
dt,
strong {
    font-weight: bold;
}

i,
em,
dfn,
cite {
    font-style: italic;
}

blockquote {
    padding-left: 1.875rem;
    margin: 0 0 1.875rem 1.875rem;
    border-left: solid 2px #474d54;
    padding-left: 30px;
    margin-top: 35px;
}

pre,
code,
kbd,
tt,
var {
    font-size: 0.875em;
    font-family: Monaco, Consolas, "Andale Mono", "DejaVu Sans Mono", monospace;
}

code,
tt,
var {
    background: rgba(0, 0, 0, 0.05);
}

kbd {
    padding: 2px 4px;
    font-size: 90%;
    color: #fff;
    background-color: #333;
    border-radius: 3px;
    box-shadow: inset 0 -1px 0 rgba(0,0,0,.25);
}

pre.md-fences {
    padding: 10px 10px 10px 30px;
    margin-bottom: 20px;
    background: #333;
}

.CodeMirror-gutters {
    background: #333;
    border-right: 1px solid transparent;
}

.enable-diagrams pre.md-fences[lang="sequence"] .code-tooltip,
.enable-diagrams pre.md-fences[lang="flow"] .code-tooltip,
.enable-diagrams pre.md-fences[lang="mermaid"] .code-tooltip {
    bottom: -2.2em;
    right: 4px;
}

code,
kbd,
tt,
var {
    padding: 2px 5px;
}

table {
    max-width: 100%;
    width: 100%;
    border-collapse: collapse;
    border-spacing: 0;
}

th,
td {
    padding: 5px 10px;
    vertical-align: top;
}

a {
    -webkit-transition: all .2s ease-in-out;
    transition: all .2s ease-in-out;
}

hr {
    background: #474d54;
    /* variable */
}

h1 {
    margin-top: 2em;
}

a {
    color: #e0e0e0;
    text-decoration: underline;
}

a:hover {
    color: #fff;
}

.md-inline-math script {
    color: #81b1db;
}

b,
th,
dt,
strong {
    color: #DEDEDE;
    /* variable */
}

mark {
    background: #D3D40E;
}

blockquote {
    color: #9DA2A6;
}

table a {
    color: #DEDEDE;
    /* variable */
}

th,
td {
    border: solid 1px #474d54;
    /* variable */
}

.task-list {
    padding-left: 0;
}

.md-task-list-item {
    padding-left: 1.25rem;
}

.md-task-list-item > input {
    top: auto;
}

.md-task-list-item > input:before {
    content: "";
    display: inline-block;
    width: 0.875rem;
    height: 0.875rem;
    vertical-align: middle;
    text-align: center;
    border: 1px solid #b8bfc6;
    background-color: #363B40;
    margin-top: -0.4rem;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before {
    content: '\221A';
    /*◘*/
    font-size: 0.625rem;
    line-height: 0.625rem;
    color: #DEDEDE;
}

/** quick open **/
.auto-suggest-container {
    border: 0px;
    background-color: #525C65;
}

#typora-quick-open {
    background-color: #525C65;
}

#typora-quick-open input{
    background-color: #525C65;
    border: 0;
    border-bottom: 1px solid grey;
}

.typora-quick-open-item {
    background-color: inherit;
    color: inherit;
}

.typora-quick-open-item.active,
.typora-quick-open-item:hover {
    background-color: #4D8BDB;
    color: white;
}

.typora-quick-open-item:hover {
    background-color: rgba(77, 139, 219, 0.8);
}

.typora-search-spinner > div {
  background-color: #fff;
}

#write pre.md-meta-block {
    border-bottom: 1px dashed #ccc;
    background: transparent;
    padding-bottom: 0.6em;
    line-height: 1.6em;
}

.btn,
.btn .btn-default {
    background: transparent;
    color: #b8bfc6;
}

.ty-table-edit {
    border-top: 1px solid gray;
    background-color: #363B40;
}

.popover-title {
    background: transparent;
}

.md-image>.md-meta {
    color: #BBBBBB;
    background: transparent;
}

.md-expand.md-image>.md-meta {
    color: #DDD;
}

#write>h3:before,
#write>h4:before,
#write>h5:before,
#write>h6:before {
    border: none;
    border-radius: 0px;
    color: #888;
    text-decoration: underline;
    left: -1.4rem;
    top: 0.2rem;
}

#write>h3.md-focus:before {
    top: 2px;
}

#write>h4.md-focus:before {
    top: 2px;
}

.md-toc-item {
    color: #A8C2DC;
}

#write div.md-toc-tooltip {
    background-color: #363B40;
}

.dropdown-menu .btn:hover,
.dropdown-menu .btn:focus,
.md-toc .btn:hover,
.md-toc .btn:focus {
    color: white;
    background: black;
}

#toc-dropmenu {
    background: rgba(50, 54, 59, 0.93);
    border: 1px solid rgba(253, 253, 253, 0.15);
}

#toc-dropmenu .divider {
    background-color: #9b9b9b;
}

.outline-expander:before {
    top: 2px;
}

#typora-sidebar {
    box-shadow: none;
    border-right: 1px dashed;
    border-right: none;
}

.sidebar-tabs {
    border-bottom:0;
}

#typora-sidebar:hover .outline-title-wrapper {
    border-left: 1px dashed;
}

.outline-title-wrapper .btn {
    color: inherit;
}

.outline-item:hover {
    border-color: #363B40;
    background-color: #363B40;
    color: white;
}

h1.md-focus .md-attr,
h2.md-focus .md-attr,
h3.md-focus .md-attr,
h4.md-focus .md-attr,
h5.md-focus .md-attr,
h6.md-focus .md-attr,
.md-header-span .md-attr {
    color: #8C8E92;
    display: inline;
}

.md-comment {
    color: #5a95e3;
    opacity: 0.8;
}

.md-inline-math svg {
    color: #b8bfc6;
}

#math-inline-preview .md-arrow:after {
    background: black;
}

.modal-content {
    background: var(--bg-color);
    border: 0;
}

.modal-title {
    font-size: 1.5em;
}

.modal-content input {
    background-color: rgba(26, 21, 21, 0.51);
    color: white;
}

.modal-content .input-group-addon {
    color: white;
}

.modal-backdrop {
    background-color: rgba(174, 174, 174, 0.7);
}

.modal-content .btn-primary {
    border-color: var(--primary-color);
}

.md-table-resize-popover {
    background-color: #333;
}

.form-inline .input-group .input-group-addon {
    color: white;
}

#md-searchpanel {
    border-bottom: 1px dashed grey;
}

/** UI for electron */

.context-menu,
#spell-check-panel,
#footer-word-count-info {
    background-color: #42464A;
}

.context-menu.dropdown-menu .divider,
.dropdown-menu .divider {
    background-color: #777777;
    opacity: 1;
}

footer {
    color: inherit;
}

@media (max-width: 1000px) {
    footer {
        border-top: none;
    }
    footer:hover {
        color: inherit;
    }
}

#file-info-file-path .file-info-field-value:hover {
    background-color: #555;
    color: #dedede;
}

.megamenu-content,
.megamenu-opened header {
    background: var(--bg-color);
}

.megamenu-menu-panel h2,
.megamenu-menu-panel h1,
.long-btn {
    color: inherit;
}

.megamenu-menu-panel input[type='text'] {
    background: inherit;
    border: 0;
    border-bottom: 1px solid;
}

#recent-file-panel-action-btn {
    background: inherit;
    border: 1px grey solid;
}

.megamenu-menu-panel .dropdown-menu > li > a {
    color: inherit;
    background-color: #2F353A;
    text-decoration: none;
}

.megamenu-menu-panel table td:nth-child(1) {
    color: inherit;
    font-weight: bold;
}

.megamenu-menu-panel tbody tr:hover td:nth-child(1) {
    color: white;
}

.modal-footer .btn-default, 
.modal-footer .btn-primary,
.modal-footer .btn-default:not(:hover) {
    border: 1px solid;
    border-color: transparent;
}

.btn-primary {
    color: white;
}

.btn-default:hover, .btn-default:focus, .btn-default.focus, .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default {
    color: white;
    border: 1px solid #ddd;
    background-color: inherit;
}

.modal-header {
    border-bottom: 0;
}

.modal-footer {
    border-top: 0;
}

#recent-file-panel tbody tr:nth-child(2n-1) {
    background-color: transparent !important;
}

.megamenu-menu-panel tbody tr:hover td:nth-child(2) {
    color: inherit;
}

.megamenu-menu-panel .btn {
    border: 1px solid #eee;
    background: transparent;
}

.mouse-hover .toolbar-icon.btn:hover,
#w-full.mouse-hover,
#w-pin.mouse-hover {
    background-color: inherit;
}

.typora-node::-webkit-scrollbar {
    width: 5px;
}

.typora-node::-webkit-scrollbar-thumb:vertical {
    background: rgba(250, 250, 250, 0.3);
}

.typora-node::-webkit-scrollbar-thumb:vertical:active {
    background: rgba(250, 250, 250, 0.5);
}

#w-unpin {
    background-color: #4182c4;
}

#top-titlebar, #top-titlebar * {
    color: var(--item-hover-text-color);
}

.typora-sourceview-on #toggle-sourceview-btn,
#footer-word-count:hover,
.ty-show-word-count #footer-word-count {
    background: #333333;
}

#toggle-sourceview-btn:hover {
    color: #eee;
    background: #333333;
}

/** focus mode */
.on-focus-mode .md-end-block:not(.md-focus):not(.md-focus-container) * {
    color: #686868 !important;
}

.on-focus-mode .md-end-block:not(.md-focus) img,
.on-focus-mode .md-task-list-item:not(.md-focus-container)>input {
    opacity: #686868 !important;
}

.on-focus-mode li[cid]:not(.md-focus-container){
    color: #686868;
}

.on-focus-mode .md-fences.md-focus .CodeMirror-code>*:not(.CodeMirror-activeline) *,
.on-focus-mode .CodeMirror.cm-s-inner:not(.CodeMirror-focused) * {
    color: #686868 !important;
}

.on-focus-mode .md-focus,
.on-focus-mode .md-focus-container {
    color: #fff;
}

.on-focus-mode #typora-source .CodeMirror-code>*:not(.CodeMirror-activeline) * {
    color: #686868 !important;
}


/*diagrams*/
#write .md-focus .md-diagram-panel {
    border: 1px solid #ddd;
    margin-left: -1px;
    width: calc(100% + 2px);
}

/*diagrams*/
#write .md-focus.md-fences-with-lineno .md-diagram-panel {
    margin-left: auto;
}

.md-diagram-panel-error {
    color: #f1908e;
}

.active-tab-files #info-panel-tab-file,
.active-tab-files #info-panel-tab-file:hover,
.active-tab-outline #info-panel-tab-outline,
.active-tab-outline #info-panel-tab-outline:hover {
    color: #eee;
}

.sidebar-footer-item:hover,
.footer-item:hover {
    background: inherit;
    color: white;
}

.ty-side-sort-btn.active,
.ty-side-sort-btn:hover,
.selected-folder-menu-item a:after {
    color: white;
}

#sidebar-files-menu {
    border:solid 1px;
    box-shadow: 4px 4px 20px rgba(0, 0, 0, 0.79);
    background-color: var(--bg-color);
}

.file-list-item {
    border-bottom:none;
}

.file-list-item-summary {
    opacity: 1;
}

.file-list-item.active:first-child {
    border-top: none;
}

.file-node-background {
    height: 32px;
}

.file-library-node.active>.file-node-content,
.file-list-item.active {
    color: white;
    color: var(--active-file-text-color);
}

.file-library-node.active>.file-node-background{
    background-color: rgb(34, 34, 34);
    background-color: var(--active-file-bg-color);
}
.file-list-item.active {
    background-color: rgb(34, 34, 34);
    background-color: var(--active-file-bg-color);
}

#ty-tooltip {
    background-color: black;
    color: #eee;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: 0.3rem;
    -webkit-appearance: none;
}

.md-mathjax-midline {
    background-color: #57616b;
    border-bottom: none;
}

footer.ty-footer {
    border-color: #656565;
}

.ty-preferences .btn-default {
    background: transparent;
}
.ty-preferences .btn-default:hover {
    background: #57616b;
}

.ty-preferences select {
    border: 1px solid #989698;
    height: 21px;
}

.ty-preferences .nav-group-item.active,
.export-item.active,
.export-items-list-control,
.export-detail {
    background: var(--item-hover-bg-color);
}

.ty-preferences input[type="search"] {
    border-color: #333;
    background: #333;
    line-height: 22px;
    border-radius: 6px;
    color: white;
}

.ty-preferences input[type="search"]:focus {
    box-shadow: none;
}

[data-is-directory="true"] .file-node-content {
    margin-bottom: 0;
}

.file-node-title {
    line-height: 22px;
}

.html-for-mac .file-node-open-state, .html-for-mac .file-node-icon {
    line-height: 26px;
}

::-webkit-scrollbar-thumb {
    background: rgba(230, 230, 230, 0.30);
}

::-webkit-scrollbar-thumb:active {
    background: rgba(230, 230, 230, 0.50);
}

#typora-sidebar:hover div.sidebar-content-content::-webkit-scrollbar-thumb:horizontal {
    background: rgba(230, 230, 230, 0.30);
}

.nav-group-item:active {
    background-color: #474d54 !important;
}

.md-search-hit {
    background: rgba(199, 140, 60, 0.81);
    color: #eee;
}

.md-search-hit * {
    color: #eee;
}

#md-searchpanel input {
    color: white;
}

.modal-backdrop.in {
    opacity: 1;
    backdrop-filter: blur(1px);
}

.clear-btn-icon {
    top: 8px;
}


mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}

g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}

.MathJax g[data-mml-node="xypic"] path {
  stroke-width: inherit;
}
mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
							stroke-width: 0;
						}
</style><title>操作系统</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='操作系统'><span>操作系统</span></h1><h2 id='1引论'><span>1.引论</span></h2><h3 id='什么是操作系统'><strong><span>什么是操作系统？</span></strong></h3><p><strong><span>操作系统</span></strong><span>是一组</span><strong><span>控制和管理计算机硬件和软件资源</span></strong><span>，</span><strong><span>合理地对各类作业进行调度</span></strong><span>，以及</span><strong><span>方便用户使用</span></strong><span>的</span><strong><span>程序的集合</span></strong><span>。</span></p><h3 id='11--操作系统的目标和作用'><span>1.1  操作系统的目标和作用</span></h3><h4 id='111-操作系统的目标'><span>1.1.1 操作系统的目标</span></h4><ol start='' ><li><span>方便性：使计算机系统更容易使用</span></li><li><span>有效性：提高系统资源利用率和提高系统的吞吐量</span></li><li><span>可扩充性：适应计算机硬件、体系结构以及应用发展的要求，能够方便地增加新的功能和模块，并能修改老的功能和模块</span></li><li><span>开放性：指系统能遵循世界标准规范</span></li></ol><h4 id='112-操作系统的作用'><span>1.1.2 操作系统的作用</span></h4><ol start='' ><li><strong><span>OS作为用户与计算机硬件系统之间的接口</span></strong><span>：OS 处于用户与计算机硬件系统之间，用户通过 OS 来使用计算机系统。</span></li><li><strong><span>OS作为计算机系统资源的管理者</span></strong><span>：一个计算机系统通常包含处理器、存储器、I/O 设备以及信息对这四类资源，OS 的主要功能也正是对这四类资源进行有效的管理进行有效的管理</span></li><li><strong><span>OS实现了对计算机资源的抽象</span></strong><span>：OS隐藏了对硬件操作的细节，由它们实现了对计算机硬件操作的多个层次的抽象。</span></li></ol><h3 id='12-操作系统的发展过程'><span>1.2 操作系统的发展过程</span></h3><h4 id='121-未配置操作系统的计算机系统'><span>1.2.1 未配置操作系统的计算机系统</span></h4><p><span>这种人工操作方式有以下两方面的缺点：</span>
<span> 　(1)  用户独占全机，即一台计算机的全部资源由上机用户所独占。</span>
<span> 　(2) CPU等待人工操作。当用户进行装带(卡)、卸带(卡)等人工操作时，CPU及内存等资源是空闲的。</span></p><h4 id='122-单道批处理系统'><span>1.2.2 单道批处理系统</span></h4><p><span>1.单道批处理系统的处理过程</span></p><p><span>为实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序，在它的控制下，使这批作业能一个接一个地连续处理。</span></p><p><img src="img/1-1.png" style="zoom:80%;" /></p><p><span>2.单道批处理系统的缺点</span></p><p><strong><span>系统中的资源得不到充分的利用</span></strong><span>。这是因为在内存中仅有一道程序，每逢该程序在运行中</span><strong><span>发出I/O请求后</span></strong><span>，</span><strong><span>CPU便处于等待状态</span></strong><span>，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。</span></p><p><img src="img/1-2.png" style="zoom:80%;" /></p><h4 id='123-多道批处理系统'><span>1.2.3 多道批处理系统</span></h4><p><span>1.多道程序设计的基本概念</span></p><p><span>在该系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备 队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享 CPU 和系统中的各种资源。</span></p><p><img src="img/1-3.png" referrerpolicy="no-referrer"></p><p><span>2.多道批处理系统的优缺点</span></p><p><span>优点：</span></p><p><span>(1) 资源利用率高。多道批处理能使多道程序交替运行，保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；还可以提高I/O设备的利用率。</span>
<span> (2) 系统吞吐量大。能提高系统吞吐量的主要原因可归结为：① CPU和其它资源保持“忙碌”状态；② 仅当作业完成时或运行不下去时才进行切换，系统开销小。</span></p><p><span>缺点：</span></p><p><span>(1) 平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。</span>
<span> (2) 无交互能力。用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极不方便。</span></p><h4 id='124-分时系统'><span>1.2.4 分时系统</span></h4><p><span>1.分时系统的引入</span></p><p><span>推动分时系统形成和发展的主要动力，则是为了</span><strong><span>满足用户对人—机交互的需求</span></strong></p><p><span>2.⭐</span><strong><span>分时系统实现中的关键问题有哪些？如何解决？</span></strong></p><p><span>关键问题是如何使用户能与自己的作业交互。</span></p><p><span>（1）及时接收：配置多路卡，并在每个终端配置缓冲区来暂存用户输入的命令或数据。</span></p><p><span>（2）及时处理：作业直接进入内存，设置一个时间片来使作业轮转运行。</span></p><p><span>3.</span><strong><span>⭐分时系统的特征</span></strong></p><ul><li><span>① 多路性：允许在一台主机上同时联接多台联机终端，系统</span><strong><span>按分时原则</span></strong><span>为每个用户服务。</span></li><li><span>② 独立性：每个用户各占一个终端，彼此独立操作，互不干扰。</span></li><li><span>③ 及时性：用户的请求能在很短的时间内获得响应。</span></li><li><span>④ 交互性：用户可通过终端与系统进行广泛的人机对话。</span></li></ul><h4 id='125-实时系统'><span>1.2.5 实时系统</span></h4><p><span>1.</span><strong><span>实时系统的概念</span></strong></p><p><span>实时系统是指系统能</span><strong><span>及时响应外部事件的请求</span></strong><span>，</span><strong><span>在规定的时间内</span></strong><span>完成对该事件的处理，并</span><strong><span>控制所有实时任务协调一致地运行</span></strong><span>。</span></p><p><span>2.实时任务的类型</span></p><p><span>(1) 周期性实时任务和非周期性实时任务。</span>
<span>(2) 硬实时任务和软实时任务。 </span></p><p><span>3.</span><strong><span>⭐实时系统与分时系统的有什么不同之处？</span></strong></p><ul><li><strong><span>①多路性</span></strong><span>：实时系统的多路性则主要表现在系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。而分时系统中的多路性则与用户情况有关，时多时少</span></li><li><strong><span>②独立性：</span></strong><span>实时系统中的每个用户在向实时系统提出服务请求时是互不干扰的；而实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰</span></li><li><strong><span>③及时性：</span></strong><span>实时系统的及时性是以控制对象所要求的开始截止时间或完成截止时间来确定的</span></li><li><strong><span>④交互性： </span></strong><span>实时系统的交互性仅限于访问系统中某些特定的专用服务程序，不像分时系统那样能向终端用户提供数据处理和资源共享等服务。</span></li><li><strong><span>⑤可靠性：</span></strong><span>分时系统要求系统可靠，但实时系统则要求系统具有高度的可靠性。</span></li></ul><h3 id='13-操作系统的基本特性'><span>1.3 操作系统的基本特性</span></h3><p><span>1.</span><strong><span>操作系统有哪些基本特性？</span></strong></p><ul><li><strong><span>并发</span></strong><span>：系统中的程序能并发执行</span></li><li><strong><span>共享</span></strong><span>：指系统中的资源可供内存中多个并发执行的进程(线程)共同使用</span></li><li><strong><span>虚拟</span></strong><span>：指通过某种技术把一个物理实体变为若干个逻辑上的对应物</span></li><li><strong><span>异步</span></strong><span>：指操作系统允许进程以异步方式允许。进程是以人们不可预知的速度向前推进，这是进程的异步性。</span></li></ul><p><span>2.</span><strong><span>⭐并发和并行有什么区别？请举例说明</span></strong></p><p><strong><span>并行性</span></strong><span>是指</span><strong><span>两个或多个事件在同一时刻</span></strong><span>发生。而</span><strong><span>并发性</span></strong><span>是指</span><strong><span>两个或多个事件在同一时间间隔</span></strong><span>内发生。 </span></p><p><span>例如，在1秒事件内，0~15ms程序A运行，15~30ms程序B运行，30~45ms程序C运行......。因此可以说，在1s时间间隔内，有3道程序同时运行，但在微观上，程序是分时交替运行的。</span></p><p><span>3.</span><strong><span>什么是临界资源？</span></strong></p><p><span>在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。</span></p><p><span>4.</span><strong><span>哪些是OS最基本的特征？</span></strong></p><p><strong><span>并发和共享</span></strong><span>是操作系统的两个最基本的特征，它们又是</span><strong><span>互为存在</span></strong><span>的条件。</span></p><p><span>一方面，</span><strong><span>资源共享</span></strong><span>是</span><strong><span>以程序的并发执行为条件</span></strong><span>的，若系统不允许程序并发执行，自然不存在资源 共享问题</span></p><p><span>另一方面，若系统不能对资源共享实施有效管理，也必然影响到程序并发执行的程度，甚至根本无法并发执行</span></p><h3 id='14-操作系统的主要功能'><span>1.4 操作系统的主要功能</span></h3><h4 id='141-处理机管理功能'><span>1.4.1 处理机管理功能</span></h4><ol start='' ><li><span>进程控制</span></li><li><span>进程同步</span></li><li><span>进程通信</span></li><li><span>调度</span></li></ol><h4 id='142-存储器管理功能'><span>1.4.2 存储器管理功能</span></h4><ol start='' ><li><span>内存分配</span></li><li><span>内存保护</span></li><li><span>地址映射</span></li><li><span>内存扩充</span></li></ol><h4 id='143-设备管理功能'><span>1.4.3 设备管理功能</span></h4><ol start='' ><li><span>缓冲管理</span></li><li><span>设备分配</span></li><li><span>设备处理</span></li></ol><h4 id='144-文件管理功能'><span>1.4.4 文件管理功能</span></h4><ol start='' ><li><span>文件存储空间的管理</span></li><li><span>目录管理</span></li><li><span>文件的读写管理和保护</span></li></ol><h4 id='145-操作系统与用户之间的接口'><span>1.4.5 操作系统与用户之间的接口</span></h4><p><span>用户接口：为方便用户直接或间接控制自己作业而设置。</span></p><p><span>程序接口：为用户程序在执行中访问系统资源而设置，是用户程序取得OS服务的唯一途径。</span></p><h3 id='15--os的结构设计⭐'><span>1.5  OS的结构设计⭐</span></h3><h4 id='151-传统操作系统结构'><span>1.5.1 传统操作系统结构</span></h4><p><span>1.无结构操作系统存在下述问题：</span></p><p><span>此时的OS是为数众多的一组过程的集合，每个过程可以任意地相互调用其它过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构。</span></p><p><span>2.模块化结构设计仍存在下述问题：</span>
<span> 　(1) 在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。</span>
<span> 　(2) 在OS设计阶段，设计者必须做出一系列的决定(决策)，每一个决定必须建立在上一个决定的基础上，但模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的“无序性”，这将使程序人员很难做到“设计中的每一步决定”都是建立在可靠的基础上</span></p><p><span>3.分层式结构OS</span></p><p><span>分层结构的主要优点有：</span>
<span> 　(1) 易保证系统的正确性。</span>
<span> 　(2) 易扩充和易维护性。</span></p><p><span>分层结构的主要缺点是</span><strong><span>系统效率降低</span></strong><span>。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。</span></p><h4 id='152-客户服务器模式'><span>1.5.2 客户/服务器模式</span></h4><p><span>1.客户/服务器模式的组成</span></p><ul><li><span>(1) 客户机</span></li><li><span>(2) 服务器</span></li><li><span>(3) 网络系统</span></li></ul><p><span>2.客户/服务器模式的优点</span></p><ul><li><span>(1) 数据的分布处理和存储。</span></li><li><span>(2) 便于集中管理。</span></li><li><span>(3) 灵活性和可扩充性。 </span></li><li><span>(4)易于改编应用软件</span></li></ul><h4 id='153-面向对象的程序设计技术简介'><span>1.5.3 面向对象的程序设计技术简介</span></h4><h4 id='154-微内核os结构⭐'><span>1.5.4 微内核OS结构⭐</span></h4><p><span>1.</span><strong><span>什么是微内核OS？</span></strong></p><ul><li><span>足够小的内核</span></li><li><span>基于客户/服务器模式</span></li><li><span>应用“机制与策略分离”原理</span></li><li><span>采用面向对象技术</span></li></ul><p><span>2.</span><strong><span>微内核有哪些基本功能？</span></strong></p><ul><li><span>进程(线程)管理               </span></li><li><span>低级存储器管理</span></li><li><span>中断和陷入处理</span></li></ul><p><span>3.</span><strong><span>微内核OS有哪些优点？</span></strong></p><ol start='' ><li><span>提高了系统的可扩展性</span></li><li><span>增强了系统的可靠性</span></li><li><span>可移植性强</span></li><li><span>提供了对分布式系统的支持</span></li><li><span>融入了面向对象技术</span></li></ol><p><span>4.</span><strong><span>微内核OS存在哪些问题？</span></strong></p><p><span>由于采用了非常小的内核，客户/服务器模式和消息传递机制，但由此运行效率有所降低。实际情况是往往还会引起更多的上下文切换。</span></p><h2 id='2进程管理'><span>2.进程管理</span></h2><h3 id='21-前趋图和程序执行-p35'><span>2.1 前趋图和程序执行 P35</span></h3><h4 id='211-前趋图-p35'><span>2.1.1 前趋图 P35</span></h4><p><span>前趋图是一个有向无循环图，用于描述进程之间执行的前后关系。图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序或前趋关系。</span></p><p><span>在前趋图中，把</span><strong><span>没有前趋</span></strong><span>的结点称为</span><strong><span>初始结点</span></strong><span>，把</span><strong><span>没有后继</span></strong><span>的结点称</span><strong><span>为终止结点</span></strong><span>。每个结点还具有一个重量，用于表示该结点所含有的程序量或程序的执行时间。 </span></p><p><span>在图2-1(a)所示的前趋图中，存在着如下前趋关系：</span>
<span> 　P1→P2，P1→P3，P1→P4，P2→P5，P3→P5，P4→P6，P4→P7，P5→P8，P6→P8，P7→P9，P8→P9</span>
<span> 或表示为：</span>
<span> P={P1, P2, P3, P4, P5, P6, P7, P8, P9}</span>
<span>  ={(P1, P2), (P1, P3), (P1, P4), (P2, P5), (P3, P5), (P4, P6), (P4, P7), (P5, P8), (P6, P8), (P7, P9), (P8, P9)}</span></p><p><span>前趋图中是</span><strong><span>不允许有循环的</span></strong><span>，否则必然会产生不可能实现的前趋关系。如图2-1(b)(p36)所示的前趋关系中，存在着循环。它一方面要求在S3开始执行之前，S2必须完成，另一方面又要求在S2开始执行之前，S3必须完成。显然，这种关系是不可能实现的。</span></p><p><img src="img/2-1.png" referrerpolicy="no-referrer"></p><h4 id='212-程序的顺序执行-p36'><span>2.1.2 程序的顺序执行 P36</span></h4><p><span>1.程序的顺序执行</span></p><p><span>一个应用程序由若干个程序段组成，它们在执行时，都需要</span><strong><span>按照某种先后次序顺序执行</span></strong><span>，仅当前一程序段执行完后，才运行后一程序段。</span></p><p>&nbsp;</p><p>&nbsp;</p><p><span>2.⭐</span><strong><span>程序顺序执行时的特征</span></strong></p><ul><li><strong><span>顺序性</span></strong><span>：指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束；</span></li><li><strong><span>封闭性</span></strong><span>：程序在封闭的环境下运行，即程序运行时独占全机资源，资源的状态只有本程序才能改变它，程序一旦开始执行，其执行结果不受外界因素影响；</span></li><li><strong><span>可再现性</span></strong><span>：指只要程序执行时的环境和初始条件相同，当程序重复执行时都可获得相同的结果。</span></li></ul><h4 id='213-程序的并发执行-p37'><span>2.1.3 程序的并发执行 P37</span></h4><p><span>1.程序的并发执行</span></p><p><span>在图2-2中的输入程序、计算程序和打印程序三者之间，存在着Ii→Ci→Pi这样的前趋关系，以至对一个作业的输入、计算和打印三个程序段必须顺序执行；但对一批作业进行处理时，每道作业的输入、计算和打印程序段的执行情况如图2-3所示。</span></p><p><img src="img/2-2.png" referrerpolicy="no-referrer"></p><p><span>由图2-3可以看出，存在前趋关系Ii→Ci，Ii→Ii+1，Ci→Pi，Ci→Ci+1，Pi→Pi+1，而Ii+1和Ci及Pi-1是重叠的，即</span><strong><span>在Pi-1和Ci以及Ii+1之间，不存在前趋关系，可以并发执行。</span></strong></p><p><span>2.⭐</span><strong><span>程序并发执行时的特征</span></strong></p><ul><li><strong><span>间断性</span></strong><span>：程序并发执行时，由于它们共享系统资源等原因形成了相互制约的关系，相互制约将导致并发程序</span><strong><span>具有“执行—暂停—执行”这种间断性的活动规律</span></strong></li><li><strong><span>失去封闭性</span></strong><span>：程序在并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去了封闭性。</span></li><li><strong><span>不可再现性</span></strong><span>：程序在并发执行时，由于失去了封闭性，其计算结果已与并发程序的执行速度有关，从而使程序的执行失去了可再现性。</span></li></ul><p><span>问题：⭐</span><strong><span>为什么说程序并发执行时失去了封闭性会使程序失去不可再现性？请举例说明。</span></strong></p><p><span>例如，有两个循环程序 A 和 B，它们共享一个变量 N。</span></p><p><span>程序 A 每执行一次时，都要做 N:=N+1 操作程 序 B 每执行一次时，都要执行 Print(N)操作，然后再将 N 置成“0”。</span></p><p><span>程序 A 和 B 以不同的 速度运行。</span></p><p><span>这样，可能出现下述三种情况(假定某时刻变量 N 的值为 n)。 </span></p><ul><li><span>(1) N:=N+1 在 Print(N)和 N:=0 之前，此时得到的 N 值分别为 n+1，n+1，0。</span></li><li><span>(2) N:=N+1 在 Print(N)和 N:=0 之后，此时得到的 N 值分别为 n，0，1。</span></li><li><span>(3) N:=N+1 在 Print(N)和 N:=0 之间，此时得到的 N 值分别为 n，n+1，0。 </span></li></ul><p><span>上述情况说明，程序在并发执行时，由于失去了封闭性，其计算结果已与并发程序的执行速度有关，从而使程序的执行失去了可再现性，亦即，程序经过多次执行后，虽然它 们执行时的环境和初始条件相同，但得到的结果却各不相同。</span></p><h3 id='22-进程的描述'><span>2.2 进程的描述</span></h3><h4 id='221-进程的定义和特征'><span>2.2.1 进程的定义和特征</span></h4><p><strong><span>1.定义</span></strong></p><ol start='' ><li><span>进程时程序的一次执行</span></li><li><span>解除是一个程序及其数据在处理及笋岗顺序执行时所发生的活动</span></li><li><span>进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行</span><strong><span>资源分配和调度的一个独立单位</span></strong></li></ol><p><strong><span>2.特征</span></strong></p><ol start='' ><li><span>动态性</span></li><li><span>并发性</span></li><li><span>独立性</span></li><li><span>异步性</span></li></ol><h4 id='222-进行的基本状态及转换'><span>2.2.2 进行的基本状态及转换</span></h4><h4 id='1进程的三种基本状态'><span>1.进程的三种基本状态</span></h4><ol start='' ><li><span>就绪：当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们 排成一个队列，称为就绪队列。</span></li><li><span>执行：进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。</span></li><li><span>阻塞：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态， 亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。 致使进程阻塞的典型事件有：请求 I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也 排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。</span></li></ol><p><strong><span>2.三种基本状态的转换</span></strong><span>	</span></p><p><span>处于就绪状态的进程，在调度程序为之分配了处理机之后，该进程便可执行，相应地，它就由就绪状态转变为执行状态。正在执行的进程也称为当前进程，如果 因分配给它的时间片已完而被暂停执行时，该进程便由执行状态又回复到就绪状态；如果因发生某事件而使进 程的执行受阻(例如，进程请求访问某临界资源，而该 资源正被其它进程访问时)，使之无法继续执行，该进 程将由执行状态转变为阻塞状态。</span></p><p><img src="img/2-3.png" style="zoom:80%;" /></p><p><strong><span>3.创建状态和终止状态</span></strong></p><p><span>（1）创建状态</span>
<span> 　如前所述，进程是由创建而产生。创建一个进程是个很复杂的过程，一般要通过多个步骤才能完成：如首先由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入就绪队列之中。但如果进程所需的资源尚不能得到满足，比如系统尚无足够的内存使进程无法装入其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。</span></p><p><span>（2) 终止状态</span>
<span> 　进程的终止也要通过两个步骤：首先，是等待操作系统进行善后处理，最后将其PCB清零，并将PCB空间返还系统。当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对其信息的提取之后，操作系统将删除该进程，即将其PCB清零，并将该空白PCB返还系统。</span></p><p><img src="img/2-6.jpg" referrerpolicy="no-referrer" alt="增加了创建状态和终止状态后进程的五种状态及转换关系图"></p><p>&nbsp;</p><h4 id='223-挂起操作和进程状态的转换'><span>2.2.3 挂起操作和进程状态的转换</span></h4><p><strong><span>1.⭐为什么要引入挂起状态？（引起进程挂起的事件）</span></strong></p><ul><li><span>① 终端用户的需要</span></li><li><span>② 父进程请求</span></li><li><span>③ 负荷调节的需要</span></li><li><span>④ 操作系统的需要</span></li></ul><p><strong><span>2.隐去挂起原语操作后三个进程状态的转换</span></strong></p><p><span>具有挂起状态的三个进程状态图：</span></p><p><img src="img/2-4.png" style="zoom:80%;" /></p><p>&nbsp;</p><p><strong><span>3.引入挂起操作后五个进程状态的转换</span></strong></p><p><span>具有创建、终止和挂起状态的五个进程状态图：</span></p><p><img src="img/2-5.png" style="zoom:80%;" /></p><h4 id='224-进程管理中的数据结构'><span>2.2.4 进程管理中的数据结构</span></h4><p><strong><span>1.操作系统中用于管理控制的数据结构</span></strong></p><p><span>OS管理的这些数据结构一般分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，通常</span><strong><span>进程表又被称为进程控制块</span></strong><span>PCB。 </span></p><p><span>2.</span><strong><span>⭐进程控制块PCB有哪些作用？</span></strong></p><ul><li><span>① 作为独立运行基本单位的标志</span></li><li><span>② 能实现间断性运行方式</span></li><li><span>③ 提供进程管理所需要的信息</span></li><li><span>④ 提供进程调度所需要的信息</span></li><li><span>⑤ 实现与其它进程的同步与通信</span></li></ul><p><span>3.</span><strong><span>⭐PCB包含哪些信息？</span></strong></p><ul><li><span>① 进程标识符，用于唯一地标识一个进程</span></li><li><span>② 处理机状态，也称为处理机的上下文，主要是由处理机的各种寄存器中的内容组成的</span></li><li><span>③ 进程调度信息，包括：</span></li><li><strong><span>进程状态</span></strong><span>，指明进程的当前状态，它是作为进程调度和对换时的依据；</span></li><li><span>	</span><strong><span>进程优先级</span></strong><span>，是用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机；</span></li><li><span>	</span><strong><span>进程调度所需的其它信息</span></strong><span>，它们与所采用的进程调度算法有关；</span></li><li><span>	</span><strong><span>事件</span></strong><span>，是指进程由执行状态转变为阻塞状态所等待发生的事件，即</span><strong><span>阻塞原因</span></strong><span>。</span></li><li><span>④ 进程控制信息，指用于进程控制所必须的信息，它包括：程序和数据的地址、进程同步和通信机制、资源清单、链接指针</span></li></ul><p><span>4.进程控制块的组织方式</span></p><ul><li><span>(1) 线性方式</span></li><li><span>(2) 链接方式</span></li><li><span>(3) 索引方式</span></li></ul><h3 id='23-进程控制⭐'><span>2.3 进程控制⭐</span></h3><p><strong><span>进程控制</span></strong><span>是进程管理中</span><strong><span>最基本的功能</span></strong><span>，主要包括</span><u><span>创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。</span></u></p><p><span>进程控制一般是由OS的内核中的原语来实现的</span></p><h4 id='231-操作系统的内核⭐'><span>2.3.1 操作系统的内核⭐</span></h4><p><span>1.内核的概念</span></p><p><span>通常将一些与硬件紧密相关的模块、各种常用设备的驱动程序以及运行频率较高的模块都安放在靠近硬件的软件层次中，通常被称为OS的内核。</span></p><p><span>2.处理机的执行状态</span></p><p><span>系统态，又称为管态，具有较高的特权，能执行一切指令。</span></p><p><span>用户态，又称为目态，只具有较低特权的执行状态，仅能执行规定的指令。</span></p><p><span>一般情况下，用户程序只能在用户态运行，不能执行OS指令及访问OS区域，这样可以防止用户程序对OS的破坏。</span></p><p><span>3.</span><strong><span>OS内核的功能</span></strong></p><p><strong><span>（1）支撑功能</span></strong></p><ul><li><span>① 中断处理</span></li><li><span>② 时钟管理</span></li><li><span>③ 原语操作</span></li></ul><p><strong><span>（2）资源管理功能</span></strong></p><ul><li><span>① 进程管理</span></li><li><span>② 存储器管理</span></li><li><span>③ 设备管理</span></li></ul><p><strong><span>4.⭐什么是原语？什么是原子操作？</span></strong></p><p><span>原语就是由一段指令组成的，用于完成一定功能的一个过。</span></p><p><span>与一般过程的区别在于，它们是</span><strong><span>原子操作。</span></strong><span>原子操作就是指一个操作中的</span><strong><span>所有动作要么全做，要么全都不做。</span></strong></p><h4 id='232-进程的创建'><span>2.3.2 进程的创建</span></h4><p><span>1.进程的层次结构</span></p><p><span>2.进程图</span></p><p><span>所谓进程图就是用于描述进程间关系的一棵有向树</span></p><p><img src="img/2-7.jpg" style="zoom:80%;" /></p><p><span>3.</span><strong><span>⭐引起创建进程的事件</span></strong></p><ul><li><span>(1) </span><strong><span>用户登录</span></strong></li><li><span>(2) </span><strong><span>作业调度</span></strong><span>。</span></li><li><span>(3) </span><strong><span>提供服务</span></strong><span>。当用户程序提出某种请求后，系统会创建一个进程来提供所请求的服务。</span></li><li><span>(4) </span><strong><span>应用请求</span></strong><span>（由应用进程自己创建） </span></li></ul><p><span>4.</span><strong><span>⭐进程的创建</span></strong></p><p><span>(1) </span><strong><span>申请空白 PCB</span></strong><span>。为新进程申请获得惟一的数字标识符，并从PCB 集合中索取一个 空白 PCB。</span></p><p><span>(2) </span><strong><span>为新进程分配资源</span></strong><span>。为新进程的程序和数据以及用户栈分配必要的内存空间。 </span></p><p><span>(3) </span><strong><span>初始化进程控制块</span></strong><span>。PCB 的初始化包括：① 初始化标识信息；② 初始化处理机状态信息；③ 初始化处理机控制信息</span><span>	</span></p><p><span>(4) </span><strong><span>将新进程插入就绪队列</span></strong><span>。如果进程就绪队列能够接纳新进程，便将新进程插入就绪 队列。</span></p><h4 id='233-进程的终止⭐'><span>2.3.3 进程的终止⭐</span></h4><p><span>1.⭐引起进程终止的事件</span></p><ul><li><span>(1) 正常结束</span></li><li><span>(2) 异常结束：在进程运行期间，由于出现某些错误和故障而迫使进程终止</span></li><li><span>(3) 外界干预：指进程应外界的请求而终止运行，如操作员或操作系统干预（死锁）。</span></li></ul><p><span>2.进程的终止过程</span></p><p><span>如果系统中发生了要求终止进程的某事件，OS便调用进程终止原语，按下述过程去终止指定的进程：</span></p><ul><li><span>(1) 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出该进程的状态</span></li><li><span>(2) 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度；</span></li><li><span>(3) 若该进程还有子孙进程，还应将其所有子孙进程也都予以终止，以防它们成为不可控的进程；</span></li><li><span>(4) 将被终止进程所拥有的全部资源或者归还给其父进程，或者归还给系统；</span></li><li><span>(5) 将被终止进程(PCB)从所在队列(或链表)中移出，等待其它程序来搜集信息。</span></li></ul><h4 id='234-进程的阻塞与唤醒⭐'><span>2.3.4 进程的阻塞与唤醒⭐</span></h4><p><span>1.有哪些引起进程阻塞的事件？</span></p><ul><li><span>(1) 向系统请求共享资源失败。</span></li><li><span>(2) 等待某种操作的完成。</span></li><li><span>(3) 新数据尚未到达。</span></li><li><span>(4) 等待新任务的到达。 </span></li></ul><p><span>2.</span><strong><span>进程阻塞过程</span></strong></p><ul><li><span>① 进程通过调用阻塞原语block将自己阻塞。</span></li><li><span>② 然后把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列。</span></li><li><span>③ 最后，转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换</span></li></ul><p><span>3.</span><strong><span>进程唤醒过程</span></strong></p><p><span>当</span><strong><span>被阻塞进程所期待的事件发生时</span></strong><span>，调用唤醒原语wakeup，将等待该事件的进程唤醒。</span></p><p><span>wakeup执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由阻塞改为就绪，然后再将该PCB插入到就绪队列中。</span></p><h4 id='235-进程的挂起与激活⭐'><span>2.3.5 进程的挂起与激活⭐</span></h4><p><span>1.为什么要引入进程的挂起？</span></p><p><a href='#224-进程管理中的数据结构'><span>引入进程的挂起的原因</span></a></p><p><span>2.进程的激活过程</span></p><p><span>当发生激活进程的事件时，若该进程驻留在外存而内存中已有足够的空间时，将在外存上处于静止就绪状态的该进程换入内存。</span></p><p><span>这时，系统将利用激活原语 active将指定进程激活。激活原语先将进程从外存调入内存，检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。</span></p><p><span>假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被 激活进程的优先级更低，就不必重新调度；否则，立即剥夺当前进程的运行，把处理机分 配给刚被激活的进程。</span></p><h3 id='24-进程同步⭐'><span>2.4 进程同步⭐</span></h3><p><span>引入进程同步的原因：</span></p><p><span>如果不能采取有效的措施，对多个进程的运行进行妥善的管理，必然会因为这些进程对系统资源的无序争夺给系统造成混乱。致使每次处理的结果存在着不确定性，即显现出其不可再现性。</span></p><h4 id='241-进程同步的基本概念'><span>2.4.1 进程同步的基本概念</span></h4><p><span>1.</span><strong><span>两种形式的制约关系</span></strong></p><p><span>（1）间接相互制约关系</span></p><p><span>（2）直接相互制约关系</span></p><p><span>2.</span><strong><span>临界资源</span></strong></p><p>&nbsp;</p><p><span>3.临界区</span></p><p><span>人们把在每个进程中访问临界资源的那段代码称为临界区</span></p><p><span>4.⭐</span><strong><span>同步机制应遵循的规则</span></strong></p><p><span>(1) </span><strong><span>空闲让进</span></strong><span>。当没有进程处于临界区时，应允许一个请求进入临界区的进程立即进入自己的临界区。</span>
<span>(2) </span><strong><span>忙则等待</span></strong><span>。当已有进程进入临界区时，其它试图进 入临界区的进程必须等待。</span>
<span>(3) </span><strong><span>有限等待</span></strong><span>。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区， 以免陷入“死等”状态。</span>
<span>(4) </span><strong><span>让权等待</span></strong><span>。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等状态。</span></p><h4 id='242-硬件同步机制'><span>2.4.2 硬件同步机制</span></h4><p><span>1.关中断</span></p><p><span>定义：在</span><strong><span>进入锁测试之前关闭中断</span></strong><span>，直到完成锁测试并上锁之后才能打开中断。这样，进程</span><strong><span>在临界区执行期间</span></strong><span>，计算机系统不响应中断，从而不会引发调度，也就</span><strong><span>不会发生进程或线程切换</span></strong><span>。是实现互斥的最简单的方法之一。</span></p><p><span>缺点：</span></p><ul><li><span>① 滥用关中断权力可能导致严重后果；</span></li><li><span>② 关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</span></li><li><span>③ 关中断方法也不适用于多CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</span></li></ul><p><span>2.利用Test-and-Set指令实现互斥</span></p><p><span>3.利用Swap指令实现进程互斥</span></p><h4 id='243-信号量机制⭐'><span>2.4.3 信号量机制⭐</span></h4><p><span>1.整型信号量</span></p><p><span>最初由 Dijkstra 把整型信号量定义为一个用于表示资源数目的整型量 S，它与一般整型 量不同，除初始化外，仅能通过两个标准的原子操作：</span></p><p><span> wait(S)和 signal(S) 来访问。这两个操作一直被分别称为 P、V 操作。</span></p><p><span>Wait(S)和 signal(S)操作可 描述为：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> wait(S)： while S&lt;=0 do no-op；</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">S:=S-1；</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="display: none; height: 78px;"></div></div></div></pre><p>&nbsp;</p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> signal(S)： S:=S+1；</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p><span>2.记录型信号量</span></p><p><span>在整型信号量机制中的 wait 操作，只要是信号量 S≤0，就会不断地测试。因此，该机制并</span><strong><span>未遵循“让权等待”</span></strong><span>的准则，而是使进程处于“忙等”的状态。</span></p><p><span>记录型信号量机制则是一种不存在“忙等”现象的进程同步机制。但在采取了“让权等待”的策略后，又会出现</span><strong><span>多个进程等待访问同一临界资源</span></strong><span>的情况。</span></p><p><span>为此，在信号量机制中，除了需要一个用于代表资源数目的整型变量 value 外，还应增加一个进程链表指针 L，用于</span><strong><span>链接上述的所有等待进程</span></strong><span>。</span></p><p><span>它所包含的上述两个数据项可描述为：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">type semaphore=record</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> value: integer；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> L: list of process；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> end </span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 104px;"></div><div class="CodeMirror-gutters" style="display: none; height: 104px;"></div></div></div></pre><p><span>相应地，wait(S)和 signal(S)操作可描述为</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">procedure wait(S)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> var S：semaphore；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> begin</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> S.value:=S.value-1；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> if S.value&lt;0 then block(S.L)；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> end</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> procedure signal(S)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> var S: semaphore；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> begin</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> S.value:=S.value+1；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> if S.value&lt;=0 then wakeup(S.L)；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> end</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 312px;"></div><div class="CodeMirror-gutters" style="display: none; height: 312px;"></div></div></div></pre><p><span>3.AND型信号量</span></p><p><span>前面所述的进程互斥问题针对的是多个并发进程</span><strong><span>仅共享一个临界资源</span></strong><span>的情况。</span></p><p><span>在有些应用场合，是一个进程往往</span><strong><span>需要获得两个或更多的共享资源</span></strong><span>后方能执行其任务。</span></p><p><span>假定现有两个进程A和B，它们都要求访问共享数据D和E，为此，可为 这两个数据分别设置用于互斥的信号量 Dmutex 和 Emutex，并令它们的初值都是 1。</span></p><p><span>相应地， 在两个进程中都要包含两个对 Dmutex 和 Emutex 的操作，即：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">process A: process B:</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> wait(Dmutex)； wait(Emutex)；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> wait(Emutex)； wait(Dmutex)；</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="display: none; height: 78px;"></div></div></div></pre><p><span>若进程 A 和 B 按下述次序交替执行 wait 操作：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> process A: wait(Dmutex)； 于是 Dmutex=0</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> process B: wait(Emutex)； 于是 Emutex=0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> process A: wait(Emutex)； 于是 Emutex=-1 A 阻塞</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> process B: wait(Dmutex)； 于是 Dmutex=-1 B 阻塞</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 104px;"></div><div class="CodeMirror-gutters" style="display: none; height: 104px;"></div></div></div></pre><p><span>最后，进程 A 和 B 处于僵持状态。在无外力作用下，两者都将无法从僵持状态中解脱出来。我们称此时的进程 A 和 B 已进入死锁状态。显然，当进程同时要求的</span><strong><span>共享资源愈多</span></strong><span>时，</span><strong><span>发生进程死锁的可能性也就愈大</span></strong><span>。</span></p><p><strong><span>AND 同步机制的基本思想</span></strong><span>是：将进程在</span><strong><span>整个运行过程中需要的所有资源</span></strong><span>，</span><strong><span>一次性全部地分配</span></strong><span>给进程，待进程使用完后再一起释放。只要尚</span><strong><span>有一个资源未能分配</span></strong><span>给进程，</span><strong><span>其它所有可能为之分配的资源也不分配</span></strong><span>给它。</span></p><p><span>为此，在 wait 操作中，增加了一个“AND”条件，故称为 AND 同步，或称为同时 wait 操作，即 Swait(Simultaneous wait)定义如下: </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Swait(S1，S2，…，Sn)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> if Si&gt;=1 and … and Sn&gt;=1 then</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> for i:=1 to n do</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Si</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">:=Si-1；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> endfor</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> else</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> place the process in the waiting queue associated with the first Si found with Si&lt;1，and set the</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">program count of this process to the beginning of Swait operation</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> endif</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Ssignal(S1，S2，…，Sn)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> for i:=1 to n do</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Si</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">:=Si+1；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Remove all the process waiting in the queue associated with Si into the ready queue.</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> endfor；</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 416px;"></div><div class="CodeMirror-gutters" style="display: none; height: 416px;"></div></div></div></pre><p><span>4.信号量集</span></p><p><span>在前面所述的记录型信号量机制中，wait(S)或signal(S)操作仅能对信号量施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。</span></p><p><span>当一次需要 N 个某类临界资源时，便要 进行 N 次 wait(S)操作，显然这是低效的。</span></p><p><span>此外，在有些情况下，当资源数量低于某一下限值时，便不予以分配。因而，在每次分配之前，都必须测试该资源的数量，看其是否大于 其下限值。</span></p><p><span>基于上述两点，可以对 AND 信号量机制加以扩充，形成一般化的“信号量集” 机制。Swait 操作可描述如下，其中 </span><strong><span>S 为信号量，d 为需求值，而 t 为下限值</span></strong><span>。</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Swait(S1，t1，d1，…，Sn，tn，dn)</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> if Si&gt;=t1 and … and Sn&gt;=tn then</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> for i:=1 to n do</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Si:=Si-di；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> endfor</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> else</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Place the executing process in the waiting queue of the first Si with Si&lt;ti and set its program counter</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">to the beginning of the Swait Operation.</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> endif</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Ssignal(S1，d1，…，Sn，dn)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> for i:=1 to n do</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Si</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">:=Si+di；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Remove all the process waiting in the queue associated with Si</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> into the ready queue</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> endfor；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 468px;"></div><div class="CodeMirror-gutters" style="display: none; height: 468px;"></div></div></div></pre><p><span>下面我们讨论</span><strong><span>一般“信号量集”的几种特殊情况</span></strong><span>：</span></p><p><span> (1) Swait(S，d，d)。此时在信号量集中只有</span><strong><span>一个信号量 S</span></strong><span>，但允许它</span><strong><span>每次申请 d 个资源</span></strong><span>，当</span><strong><span>现有资源数少于 d</span></strong><span> 时，不予分配。</span></p><p><span> (2) Swait(S，1，1)。此时的信号量集已退化为</span><strong><span>一般的记录型信号量(S&gt;1 时)</span></strong><span>或</span><strong><span>互斥信号量(S=1 时)</span></strong><span>。</span></p><p><span> (3) Swait(S，1，0)。这是一种很特殊且很有用的信号量操作。当 </span><strong><span>S≥1</span></strong><span> 时，</span><strong><span>允许多个进程进入某特定区</span></strong><span>；当 </span><strong><span>S 变为 0</span></strong><span> 后，将</span><strong><span>阻止任何进程</span></strong><span>进入特定区。换言之，它相当于一个可控开关。</span></p><h4 id='244-信号量的应用⭐'><span>2.4.4 信号量的应用⭐</span></h4><p><span>1.⭐</span><strong><span>利用信号量实现进程互斥</span></strong></p><p><span>为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。 </span></p><p><span>这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对 mutex 执行 wait 操作，若该资源此刻未被访问，本次 wait 操作必然成功，进程便可进入自己的临界区， 这时若再有其他进程也欲进入自己的临界区，此时由于对 mutex 执行 wait 操作定会失败，因而该进程阻塞，从而保证了该临界资源能被互斥地访问。当访问临界资源的进程退出临 界区后，又应对 mutex 执行 signal 操作，以便释放该临界资源。</span></p><p><span>利用信号量实现两个进程互斥的描述如下：</span></p><p><span>（1）设mutex为互斥信号量，初值为1，取值范围为(-1, 0, 1）。</span></p><p><span>		</span><span>mutex=1：两个进程均未进入需要互斥的临界区</span></p><p><span>		</span><span>mutex=0：有一个进程进入临界区，另一个必须等待</span></p><p><span>		</span><span>mutex=-1：有一个进程进入临界区，另一个因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒</span></p><p><span>（2）代码描述 P61</span></p><p><span>2.</span><strong><span>利用信号量实现前趋关系</span></strong></p><p><span>设有两个并发执行的进程P1和P2。P1中有语句S1；P2中有语句S2。</span></p><p><span>我们希望在S1执行后再执行S2。为实现这种前趋关系，只需使进程P1和P</span><strong><span>2共享一个公用信号量S</span></strong><span>，并赋予其初值为0，</span><strong><span>将signal(S)操作放在语句S1后面</span></strong><span>，而</span><strong><span>在S2语句前面插入wait(S)操作</span></strong><span>，即</span>
<span> 　在进程P1中，用S1；signal(S)；</span>
<span> 　在进程P2中，用wait(S)；S2；</span></p><p><span>由于S被初始化为0，这样，若P2先执行必定阻塞，只有在进程P1执行完S1； signal(S)；操作后使S增为1时，P2进程方能成功执行语句S2。</span></p><p><img src="img/2-8.jpg" referrerpolicy="no-referrer"></p><h4 id='245-管程机制⭐'><span>2.4.5 管程机制⭐</span></h4><p><span>1.</span><strong><span>管程的定义</span></strong></p><p><span>一个管程定义了</span><strong><span>一个数据结构</span></strong><span>和</span><strong><span>能为并发进程所执行的一组操作</span></strong><span>，这组操作能</span><strong><span>同步进程和改变管程中的数据</span></strong><span>。</span></p><p><span>由上述的定义可知，管程由四部分组成：</span></p><ul><li><span>① 管程的名称；</span></li><li><span>② 局部于管程的共享数据结构说明；</span></li><li><span>③ 对该数据结构进行操作的一组过程；</span></li><li><span>④ 对局部于管程的共享数据设置初始值的语句</span></li></ul><p><img src="img/2-9.jpg" referrerpolicy="no-referrer" alt="管程示意图"></p><p><span>2.⭐</span><strong><span>管程与进程有什么不同？</span></strong></p><ul><li><span>① 数据结构。进程定义的是私有数据结构PCB，管程定义的是公共数据结构，如消息队列等</span></li><li><span>② 对数据结构的操作。进程是顺序程序执行有关结构，而管程主要是进行同步操作和初始化操作</span></li><li><span>③ 设置的目的。设置进程的目的在于实现系统的并发性，设置管程是为了解决共享资源的互斥使用问题；</span></li><li><span>④ 工作方式。进程通过调用管程中的过程对共享数据进行操作，该过程就如子程序被调用，因而管程为被动工作方式，进程为主动工作方式</span></li></ul><p><span>2.条件变量</span></p><p><span>在利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语wait和signal。当</span><strong><span>某进程通过管程请求获得临界资源而未能满足</span></strong><span>时，管程便调用wait原语使该进程等待，并将其排在等待队列上，如图所示。仅当</span><strong><span>另一进程访问完成并释放该资源之后</span></strong><span>，管程才又调用signal原语，唤醒等待队列中的队首进程。</span></p><p>&nbsp;</p><p>&nbsp;</p><h3 id='25-经典进程同步问题⭐'><span>2.5 经典进程同步问题⭐</span></h3><h4 id='251-生产者-消费者问题'><span>2.5.1 生产者-消费者问题</span></h4><p>&nbsp;</p><h4 id='252-哲学家进餐问题'><span>2.5.2 哲学家进餐问题</span></h4><p>&nbsp;</p><h4 id='253-读者-写者问题'><span>2.5.3 读者-写者问题</span></h4><p>&nbsp;</p><h3 id='26-进程通信'><span>2.6 进程通信</span></h3><p><strong><span>进程通信是指进程之间的信息交换。</span></strong></p><h4 id='261-进程通信的类型'><span>2.6.1 进程通信的类型</span></h4><p><span>1.共享存储器系统：在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信</span></p><p><span>2.管道通信系统：所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件。</span></p><p><span>向管道(共享文件)提供输入的发送进程(即写进程)以字符流形式将大量的数据送入管道；而接受管道输出的接收进程(即读进程)则从管道中接收(读)数据。</span></p><p><span>3.</span><strong><span>⭐消息传递系统</span></strong><span>：在该机制中</span><strong><span>以格式化的消息为单位</span></strong><span>，将通信的</span><strong><span>数据封装在消息</span></strong><span>中，并利用操作系统提供的一组通信命令(原语)，在进程间进行消息传递，完成进程间的数据交换。基于消息传递系统的通信方式属于</span><strong><span>高级通信方式</span></strong><span>。</span></p><p><span>4.客户机-服务器系统</span></p><p><span>3种实现方法：</span></p><p><span>（1） 套接字</span></p><p><span>（2）远程过程调用</span></p><p><span>（3）远程方法调用</span></p><h4 id='262-消息传递通信的实现方式'><span>2.6.2 消息传递通信的实现方式</span></h4><p><span>1.直接消息传递系统</span></p><p><span>在直接消息传递系统中采用直接通信方式，即发送进程</span><strong><span>利用OS所提供的发送命令</span></strong><span>(原语)，</span><strong><span>直接把消息发送给目标进程</span></strong><span>。</span></p><p><span>（1）直接通信原语：对称寻址方式，非对称寻址方式 send receive</span></p><p><span>（2）消息的格式</span></p><p><span>（3）进程的同步方式：不论是发送进程还是接收进程，在完成消息的发送或接收后，都存在两种可能性，即进程或者继续发送(或接收)或者阻塞。 </span></p><ul><li><span>① 发送进程阻塞，接受进程阻塞</span></li><li><span>② 发送进程不阻塞，接受进程阻塞</span></li><li><span>③ 发送进程和接收进程都不阻塞</span></li></ul><p><span>（4）通信链路：单向通信链路，双向通信链路</span></p><p><span>2.信箱通信（属于间接通信方式）</span></p><p><span>（1）信箱的结构</span>
<span> 　信箱定义为一种数据结构。在逻辑上，可以将其分为两个部分：</span>
<span> 　(1) 信箱头</span>
<span> 　(2) 信箱体</span></p><p><img src="img/2-10.jpg" referrerpolicy="no-referrer" alt="双向信箱示意图"></p><p><span>（2）信箱通信原语</span>
<span> 　系统为邮箱通信提供了若干条原语，分别用于：</span>
<span> 　① 邮箱的创建和撤消 　② 消息的发送和接收</span></p><p><span>（3）信箱的类型</span></p><ul><li><span>① 私用信箱：用户进程创建</span></li><li><span>② 公用信箱：OS创建</span></li><li><span>③ 共享信箱：某进程创建</span></li></ul><h4 id='263-直接消息传递系统实例'><span>2.6.3 直接消息传递系统实例</span></h4><h3 id='27-线程的基本概念'><span>2.7 线程的基本概念</span></h3><h4 id='271-线程的引入⭐'><span>2.7.1 线程的引入⭐</span></h4><p><strong><span>为什么要引入进程？</span></strong></p><p><span>为了</span><strong><span>使多个程序能并发执行</span></strong><span>，以提高资源利用率和系统吞吐量</span></p><p><strong><span>为什么要引入线程？</span></strong></p><p><span>为了</span><strong><span>减少程序在并发执行时所付出的时空开销</span></strong><span>，使OS具有</span><strong><span>更好的并发性</span></strong></p><p><span>1.</span><strong><span>进程的两个基本属性（什么是进程？）⭐</span></strong></p><p><span>① </span><strong><span>进程是一个可拥有资源的独立单位</span></strong><span>。一个进程要能独立运行，它必须拥有一定的资源，包括用于磁盘和内存地址空间，和I/O设备、已打开的文件、信号量等；</span></p><p><span>② </span><strong><span>进程同时又是一个可独立调度和分派的基本单位</span></strong><span>。每个进程在系统中有唯一的PCB，系统根据其PCB感知进程的存在，也可以根据其PCB中的信息，对进程进行调度，还可将断点信息保存在其PCB中。反之，再</span><strong><span>利用进程PCB中的信息</span></strong><span>来</span><strong><span>恢复进程运行的现场</span></strong><span>。正是由于进程有这两个基本属性，才使进程</span><strong><span>成为一个能独立运行的基本单位</span></strong><span>，从而也就构成了进程并发执行的基础。</span></p><p><span>2.程序并发执行所需付出的时空开销</span></p><ul><li><span>(1) </span><strong><span>创建进程</span></strong><span>，系统在创建一个进程时，必须为它分配其所必需的、除处理机以外的所有资源，如内存空间、I/O设备，以及建立相应的PCB；</span></li><li><span>(2) </span><strong><span>撤消进程</span></strong><span>，系统在撤消进程时，又必须先对其所占有的资源执行回收操作，然后再撤消PCB；</span></li><li><span>(3) </span><strong><span>进程切换</span></strong><span>，对进程进行上下文切换时，需要</span><strong><span>保留当前进程的CPU环境</span></strong><span>，设置新选中进程的CPU环境。</span></li></ul><p><span>3.线程——作为调度和分派的基本单位</span></p><p><span>如何能使多个程序更好地并发执行，同时又尽量减少系统的开销。有不少学者想到，要设法将进程的上述两个属性分开，由OS分开处理，亦即并</span><strong><span>不把作为调度和分派的基本单位</span></strong><span>也</span><strong><span>同时作为拥有资源的单位</span></strong><span>。而对于</span><strong><span>拥有资源的基本单位</span></strong><span>，不对其进行频繁切换。正是在这种思想的指导下，形成了线程的概念。</span></p><h4 id='272-线程与进程的比较线程和进程有什么不同）⭐'><span>2.7.2 线程与进程的比较（线程和进程有什么不同？）⭐</span></h4><ol start='' ><li><span>调度的基本单位</span></li><li><span>并发性</span></li><li><span>拥有资源 </span></li><li><span>独立性</span></li><li><span>系统开销</span></li><li><span>支持多处理机系统</span></li></ol><h4 id='273-线程的状态和线程控制块'><span>2.7.3 线程的状态和线程控制块</span></h4><p><span>1.线程运行的三个状态</span></p><p><span>(1) 执行状态，表示线程已获得处理机而正在运行；</span>
<span>(2) 就绪状态，指线程已具备了各种执行条件，只须再获得CPU便可立即执行；</span>
<span>(3) 阻塞状态，指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞。</span></p><p><span>2.线程控制块TCB</span></p><p><span>每个线程配置了一个线程控制块TCB，将所有用于控制和管理线程的信息记录在线程控制块中。 </span></p><p><span>3.多线程OS中的进程属性</span></p><p><span>(1) 进程是一个</span><strong><span>可拥有资源的基本单位</span></strong><span>。</span>
<span>(2) </span><strong><span>多个线程可并发执行</span></strong><span>。 </span>
<span>(3) </span><strong><span>进程已不是可执行的实体</span></strong><span>。</span></p><h3 id='28-线程的实现'><span>2.8 线程的实现</span></h3><h4 id='281-线程的实现方式⭐'><span>2.8.1 线程的实现方式⭐</span></h4><p><span>1.</span><strong><span>内核支持线程KST</span></strong></p><p><span>OS中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。而内核支持线程KST同样也是在内核的支持下运行的，它们的创建、阻塞、撤消和切换等，也都是在内核空间实现的。为了对内核线程进行控制和管理，在内核空间也为每一个内核线程设置了一个线程控制块，内核根据该控制块而感知某线程的存在，并对其加以控制。当前大多数OS都支持内核支持线程。</span></p><p><span>优点：</span>
<span> 　① 在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行；</span>
<span> 　② 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</span>
<span> 　③ 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</span>
<span> 　④ 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</span>
<span>缺点：用户线程切换代价大（用户态-&gt;内核态）</span></p><p><span>2.用户级线程ULT</span></p><p><span>用户级线程是在用户空间中实现的。对线程的创建、 撤消、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。在一个系统中的用户级线程的数目可以达到数百个至数千个。由于这些线程的任务控制块(TCB)都是设置在用户空间，而线程所执行的操作也无需内核的帮助，因而内核完全不知道用户级线程的存在。</span></p><p><span>优点：</span>
<span> 　① 线程切换不需要转换到内核空间。</span>
<span> 　② 调度算法可以是进程专用的。</span>
<span> 　③ 用户级线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。</span></p><p><span>缺点：</span>
<span> 　① 系统调用的阻塞问题。在基于进程机制的OS中，大多数系统调用将使进程阻塞，因此，当线程执行一个系统调用时，不仅该线程被阻塞，而且，进程内的所有线程会被阻塞。而在内核支持线程方式中，则进程中的其它线程仍然可以运行。</span>
<span> 　②  在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点，内核每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，其它线程只能等待</span></p><h4 id='282-线程的实现'><span>2.8.2 线程的实现</span></h4><p><span>1.内核支持线程的实现</span></p><p><span>在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个线程控制块TCB空间，如图所示。</span></p><p><img src="img/2-11.jpg" referrerpolicy="no-referrer"></p><p><span>2.用户级线程的实现</span></p><p><span>有两种方式实现，</span><strong><span>运行时系统和内核控制线程</span></strong></p><p><span>（1）运行时系统</span></p><p><span>所谓“运行时系统”，实质上是用于管理和控制线程的函数(过程)的集合，其中包括用于创建和撤消线程的函数、线程同步和通信的函数，以及实现线程调度的函数等。正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。</span></p><p><span>（2）内核控制线程</span></p><p><span>这种线程又称为轻型进程LWP。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构(如TCB)，其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。LWP也可以共享进程所拥有的资源。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只须将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是</span><strong><span>组合方式</span></strong></p><p><img src="img/2-12.jpg" alt="利用轻型进程作为中间系统" style="zoom:80%;" /></p><p>&nbsp;</p><h4 id='283-线程的创建和终止'><span>2.8.3 线程的创建和终止</span></h4><p><span>1.线程的创建</span></p><p><span>应用程序在启动时，通常仅有一个线程在执行，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。</span></p><p><span>2.线程的终止</span></p><p><span>当一个线程</span><strong><span>完成了自己的任务</span></strong><span>后，或是线程在运行中</span><strong><span>出现异常情况而须被强行终止</span></strong><span>时，由终止线程通过调用相应的函数(或系统调用)对它执行终止操作。</span></p><p>&nbsp;</p><h2 id='3调度和死锁'><span>3.调度和死锁</span></h2><h3 id='31-调度的层次和调度算法的目标'><span>3.1 调度的层次和调度算法的目标</span></h3><h4 id='311-处理机调度的层次'><span>3.1.1 处理机调度的层次</span></h4><ol start='' ><li><strong><span>高级调度</span></strong><span>：又称</span><strong><span>作业调度</span></strong><span>，调度对象是作业。主要功能是根据某种算法决定调入哪些作业，为它们创建进程和分配资源。</span></li><li><strong><span>低级调度</span></strong><span>：又称</span><strong><span>进程调度</span></strong><span>，调度对象是进程，主要功能是根据某种算法决定就绪队列的哪个进程获得处理机。</span></li><li><strong><span>中级调度</span></strong><span>：又称为内存调度，作用是提高内存利用率和系统吞吐量。主要功能是把暂时不能运行的进程调至外存等待，当进程具备运行条件或内存有空闲时，重新调入内存。中级调度实际上就是</span><strong><span>对换</span></strong><span>功能。</span></li></ol><h4 id='312-处理机调度算法的目标'><span>3.1.2 处理机调度算法的目标</span></h4><p><span>1.⭐</span><strong><span>处理机调度算法的共同目标</span></strong></p><p><span>①</span><strong><span>资源利用率</span></strong><span>：指 </span><strong><span>CPU有效工作时间</span></strong><span> 比上 </span><strong><span>CPU有效工作时间加CPU空闲等待时间</span></strong></p><p><span>②</span><strong><span>公平性</span></strong><span>：指应使各进程都</span><strong><span>获得合理的CPU时间</span></strong><span>，不会发生进程饥饿现象</span></p><p><span>③</span><strong><span>平衡性</span></strong><span>：指系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应能保持系统资源使用的平衡性</span></p><p><span>④</span><strong><span>策略强制执行</span></strong><span>：对于所制定的策略，只要需要，就必须准确的执行</span></p><p><span>2.批处理系统的目标</span></p><ul><li><span>①平均周转时间短</span></li><li><span>②系统吞吐量高</span></li><li><span>③处理机利用率高</span></li></ul><p><span>3.分时系统的目标</span></p><ul><li><span>①响应时间快</span></li><li><span>②均衡性</span></li></ul><p><span>4.实时系统的目标</span></p><ul><li><span>①截止时间保证</span></li><li><span>②可预测性</span></li></ul><h3 id='32-作业和作业调度'><span>3.2 作业和作业调度</span></h3><h4 id='321-批处理系统中的作业'><span>3.2.1 批处理系统中的作业</span></h4><p><span>1.</span><strong><span>什么是作业？</span></strong></p><p><span>作业包含了通常的程序和数据，和一份作业说明书，系统根据说明书来对程序的运行进行控制。</span></p><p><span>2.什么是作业控制块JCB？</span></p><p><span>作业控制块是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。</span></p><h4 id='322-作业调度的主要任务⭐'><span>3.2.2 作业调度的主要任务⭐</span></h4><p><span>作业调度的主要功能是根据作业控制块中的信息，审查系统能否满足用户作业的资源需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为它们</span><strong><span>创建进程、分配必要的资源</span></strong><span>。然后再将新创建的进程</span><strong><span>插入就绪队列</span></strong><span>，准备执行。</span></p><p><span>在每次执行作业调度时，都须做出以下两个决定：</span></p><p><span>(1)决定接纳多少个作业：这取决于多道程序度， 即同时允许多少个作业在内存中运行。多道程序度的确定应根据系统的规模和运行速度等情况做适当的折衷。</span></p><p><span>(2)决定接纳哪些作业：应将哪些作业从外存调入内存，这将取决于所采用的调度算法。</span></p><h4 id='323-先来先服务fcfs和短作业优先sjf调度算法⭐'><span>3.2.3 先来先服务FCFS和短作业优先SJF调度算法⭐</span></h4><p><span>1.</span><strong><span>先来先服务调度算法FCFS</span></strong></p><p><span>FCFS调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。</span></p><p><span>当在作业调度中采用该算法时，每次调度都是</span><strong><span>从后备作业队列中选择一个或多个最先进入该队列的作业</span></strong><span>，将它们调入内存，为它们分配资源、创建进程，然后放 入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件 而阻塞后才放弃处理机。 FCFS 算法比较</span><strong><span>有利于长作业(进程)，而不利于短作业(进程)</span></strong><span>。</span></p><p><span>2.</span><strong><span>短作业优先调度算法SJF</span></strong></p><p><span>（1）概念：SJF算法是以作业的长短来计算优先级，作业越短，优先级越高。而作业的长短又以作业所要求的运行时间来衡量的。</span></p><p><span>（2）缺点：</span></p><ul><li><span>①必须预知作业的运行时间，但一般难以估计作业的运行时间</span></li><li><span>②该算法对长作业不利，长作业的周转时间会明显增长。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些(即使是后进来的)短作业，将导致长作业(进程)长期不被调度</span></li><li><span>③该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理。</span></li><li><span>④采用该算法时，无法实现人机交互</span></li></ul><h4 id='324-优先级调度算法和高响应比优先调度算法⭐'><span>3.2.4 优先级调度算法和高响应比优先调度算法⭐</span></h4><p><span>1.优先级调度算法PSA</span></p><p><span>（1）概念：在优先级调度算法中，是基于作业的紧迫程度，由外部赋予作业相应的优先级，调度算法根据该优先级进行调度的。</span></p><p><span>（2）优点：</span><strong><span>可以保证紧迫性作业优先运行</span></strong></p><p><span>2.高响应比优先调度算法HRRN</span></p><p><span>（1）概念：高响应比优先调度算法是考虑了作业的等待时间和作业的运行时间的调度算法</span></p><p><span>（2）优点：既照顾了短作业，又不会使长作业的等待时间过长，从而改善了处理机的调度性能。</span></p><p><span>（3）实现：为每个作业引入一个动态优先级，令它随等待时间延长而增加，这使得长作业的优先级在等待期间不断增加，等到足够的时间后，必然有机会获得处理机。</span></p><p><span>优先级的变化规律如下：</span></p><p><strong><span>优先权 = 等待时间+要求服务时间 / 要求服务时间</span></strong></p><p><span>该优先级又相当于相应比Rp</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n737" cid="n737" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="41.103ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 18167.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path><path id="MJX-1-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path><path id="MJX-1-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path><path id="MJX-1-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path id="MJX-1-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path><path id="MJX-1-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-1-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(759,0)"><use data-c="1D45D" xlink:href="#MJX-1-TEX-I-1D45D"></use></g><g data-mml-node="mo" transform="translate(1539.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(2595.6,0)"><use data-c="1D464" xlink:href="#MJX-1-TEX-I-1D464"></use></g><g data-mml-node="mi" transform="translate(3311.6,0)"><use data-c="1D44E" xlink:href="#MJX-1-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(3840.6,0)"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(4185.6,0)"><use data-c="1D461" xlink:href="#MJX-1-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(4768.8,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(5769,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(6369,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(6835,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(7301,0)"><use data-c="1D451" xlink:href="#MJX-1-TEX-I-1D451"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(7821,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-1-TEX-N-2F"></use></g></g><g data-mml-node="mi" transform="translate(8321,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(8921,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(9387,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(9853,0)"><use data-c="1D451" xlink:href="#MJX-1-TEX-I-1D451"></use></g><g data-mml-node="mo" transform="translate(10650.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(11706.6,0)"><use data-c="1D45F" xlink:href="#MJX-1-TEX-I-1D45F"></use></g><g data-mml-node="mi" transform="translate(12157.6,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(12623.6,0)"><use data-c="1D460" xlink:href="#MJX-1-TEX-I-1D460"></use></g><g data-mml-node="mi" transform="translate(13092.6,0)"><use data-c="1D45D" xlink:href="#MJX-1-TEX-I-1D45D"></use></g><g data-mml-node="mi" transform="translate(13595.6,0)"><use data-c="1D45C" xlink:href="#MJX-1-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(14080.6,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(14680.6,0)"><use data-c="1D460" xlink:href="#MJX-1-TEX-I-1D460"></use></g><g data-mml-node="mi" transform="translate(15149.6,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(15615.6,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-1-TEX-N-2F"></use></g></g><g data-mml-node="mi" transform="translate(16115.6,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mi" transform="translate(16715.6,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(17181.6,0)"><use data-c="1D452" xlink:href="#MJX-1-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(17647.6,0)"><use data-c="1D451" xlink:href="#MJX-1-TEX-I-1D451"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mi>p</mi><mo>=</mo><mi>w</mi><mi>a</mi><mi>i</mi><mi>t</mi><mo>+</mo><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo>=</mo><mi>r</mi><mi>e</mi><mi>s</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>e</mi><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><mi>n</mi><mi>e</mi><mi>e</mi><mi>d</mi></math></mjx-assistive-mml></mjx-container></div></div><p><span>从上式可以看出：</span></p><p><span>①如果作业的等待时间相同，则要求服务的时间越短，其优先级越高，有利于短作业</span></p><p><span>②如果要求服务时间相同，则作业的等待时间越长，其优先级越高，类似FCFS</span></p><p><span>③对于长作业的优先级，可以随等待时间增加的提高，当足够长时，也可以获得处理机</span></p><p><span>缺点：每次进行调度前，都要计算响应比，增加了系统开销</span></p><h3 id='33-进程调度⭐'><span>3.3 进程调度⭐</span></h3><h4 id='331-进程调度的任务机制和方式'><span>3.3.1 进程调度的任务、机制和方式</span></h4><p><span>1.</span><strong><span>进程调度的任务有哪些？</span></strong></p><p><strong><span>①保存处理机的现场信息</span></strong></p><p><strong><span>②按某种算法选取进程</span></strong></p><p><strong><span>③把处理机分配给进程</span></strong></p><p><span>2.进程调度机制</span></p><p><span>3.⭐</span><strong><span>进程调度方式有哪些？</span></strong></p><p><span>（1）</span><strong><span>非抢占方式</span></strong></p><p><span>定义：采用这种调度方式时，一旦把处理机分配给某进程后，就一直让它运行下去，直到该进程完成或被阻塞时，才把处理机分配给其他进程。</span></p><p><span>采用非抢占调度方式时，可能会引起进程调度的原因：</span></p><p><span>①正在执行的进程运行完毕，或因发生某事件而无法继续运行</span></p><p><span>②正在执行的进程因提出IO请求而被暂停执行</span></p><p><span>③在进程通信或同步过程中，执行了某种原语操作，如Block原语</span></p><p><span>优点：实现简单，系统开销小</span></p><p><span>缺点：不能用于分时系统和大多数实时系统</span></p><p><span>（2）</span><strong><span>抢占方式</span></strong></p><p><span>定义：这种调度方式允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。</span></p><p><span>优点：</span></p><p><span>①能够实现人机交互</span></p><p><span>②能满足实时系统中实时任务的需求</span></p><p><span>缺点：抢占分时比较复杂，付出的系统开销也较大</span></p><p><strong><span>⭐抢占需要遵循的原则</span></strong><span>：</span></p><p><span>①</span><strong><span>优先权原则</span></strong><span>，指允许优先级高的新到进程抢占当前进程的处理机</span></p><p><span>②</span><strong><span>短进程优先原则</span></strong><span>，指允许新到的短进程抢占当前长进程的处理机</span></p><p><span>③</span><strong><span>时间片原则</span></strong><span>，即</span><strong><span>各进程按时间片轮转进行时</span></strong><span>，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进行调度</span></p><h4 id='332-轮转调度算法⭐'><span>3.3.2 轮转调度算法⭐</span></h4><p><span>1.轮转法的基本原理</span></p><p><span>在轮转法中，系统将所有就绪进程按FCFS排成一个就绪队列， 每次调度时，把CPU分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，系统产生一次中断请求，调度程序停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中 新的队首进程。</span></p><p><span>这样就可以</span><strong><span>保证就绪队列中的所有进程</span></strong><span>在一 给定的时间内均能获得一次CPU执行。换言之，</span><strong><span>系统能在给定的时间内响应所有用户的请求</span></strong><span>。</span></p><p><span>2.⭐进程切换时机</span></p><p><span>①若一个时间片尚未用完，但进程已经完成，就立即进行进程切换</span></p><p><span>②一个时间片用完时，计时器中断处理机程序被激活，进行进程切换。如果进程尚未运行完毕，则调度程序把它送到队尾</span></p><p><span>3.⭐</span><strong><span>如何确定时间片大小？</span></strong></p><p><strong><span>一个较为可取的时间片大小时略大于一次典型交互所需要的时机，使大多数交互式进程能在一个时间片内完成，从而可以获得较小的响应时间。</span></strong></p><p><strong><span>时间片选的过小</span></strong><span>，会</span><strong><span>频繁的执行进程调度和进程上下文切换</span></strong><span>，增加了系统开销。</span></p><p><strong><span>时间片选的过大</span></strong><span>，会使每个进程都能在一个时间片内完成，RR算法便</span><strong><span>退化为FCFS</span></strong><span>，无法满足短作业和交互式用户的需求</span></p><p><img src="img/3-1.png" referrerpolicy="no-referrer"></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n781" cid="n781" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="28.924ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 12784.5 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-2-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-2-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(852.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(1704.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(2557.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(3687.3,0)"><use data-c="3D" xlink:href="#MJX-2-TEX-N-3D"></use></g><g data-mml-node="mtext" transform="translate(4743.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(5595.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">成</text></g><g data-mml-node="mtext" transform="translate(6447.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(7300.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(8374.8,0)"><use data-c="2212" xlink:href="#MJX-2-TEX-N-2212"></use></g><g data-mml-node="mtext" transform="translate(9375,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">到</text></g><g data-mml-node="mtext" transform="translate(10227.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">达</text></g><g data-mml-node="mtext" transform="translate(11079.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(11932.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>周</mtext><mtext>转</mtext><mtext>时</mtext><mtext>间</mtext><mo>=</mo><mtext>完</mtext><mtext>成</mtext><mtext>时</mtext><mtext>间</mtext><mo>−</mo><mtext>到</mtext><mtext>达</mtext><mtext>时</mtext><mtext>间</mtext></math></mjx-assistive-mml></mjx-container></div></div><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n782" cid="n782" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="31.147ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 13766.8 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-3-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-3-TEX-N-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">带</text></g><g data-mml-node="mtext" transform="translate(852.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">权</text></g><g data-mml-node="mtext" transform="translate(1704.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(2557.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(3409.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(4261.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(5392,0)"><use data-c="3D" xlink:href="#MJX-3-TEX-N-3D"></use></g><g data-mml-node="mtext" transform="translate(6447.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">周</text></g><g data-mml-node="mtext" transform="translate(7300.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">转</text></g><g data-mml-node="mtext" transform="translate(8152.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(9004.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(9857.3,0)"><g data-mml-node="mo"><use data-c="2F" xlink:href="#MJX-3-TEX-N-2F"></use></g></g><g data-mml-node="mtext" transform="translate(10357.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">服</text></g><g data-mml-node="mtext" transform="translate(11209.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">务</text></g><g data-mml-node="mtext" transform="translate(12062.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(12914.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>带</mtext><mtext>权</mtext><mtext>周</mtext><mtext>转</mtext><mtext>时</mtext><mtext>间</mtext><mo>=</mo><mtext>周</mtext><mtext>转</mtext><mtext>时</mtext><mtext>间</mtext><mrow data-mjx-texclass="ORD"><mo>/</mo></mrow><mtext>服</mtext><mtext>务</mtext><mtext>时</mtext><mtext>间</mtext></math></mjx-assistive-mml></mjx-container></div></div><p><img src="img/3-2.png" referrerpolicy="no-referrer"></p><h4 id='333-优先级调度算法'><span>3.3.3 优先级调度算法</span></h4><p><span>1.优先级调度算法的类型</span></p><p><span>优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。</span></p><p><span>（1）非抢占式优先级调度算法。一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直到完成，或者因该进程发生某事件而放弃处理机时，系统才可将处理机分配给另一优先级最高的进程。</span></p><p><span>（2）抢占式优先级调度算法。把处理机分配给优先级最高的进程。但在进程执行期间，只要出现了另一个优先级更高的进程，系统就把处理机分配给新到的优先级最高的进程。</span></p><p><span>2.优先级的类型</span></p><p><span>（1）静态优先级</span></p><p><span>静态优先级时在创建进程时确定的，在进程运行期间不变。</span></p><p><span>（2）动态优先级</span></p><p><span>动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变。</span></p><h4 id='334-多队列调度算法'><span>3.3.4 多队列调度算法</span></h4><p><strong><span>单一就绪队列的缺点：</span></strong><span> 无法满足系统中不同用户对进程调度策略的不同要求</span></p><p><strong><span>多队列调度算法概念</span></strong><span>：将系统的就绪队列从一个拆分为若干个，将</span><strong><span>不同类型或性质的进程固定分配在不同的就绪队列</span></strong><span>，不同的就绪队列采用</span><strong><span>不同的调度算法</span></strong><span>，一个就绪队列的进程可以设置不同的优先级，</span><strong><span>不同的就绪队列本身也可以设置不同的优先级</span></strong><span>。</span></p><p><span>多队列调度算法优点：满足了不同用户的不同需求，很容易提供多种调度策略。在多处理机系统中，还可以对每个处理机实施不同的调度策略。</span></p><h4 id='335-多级反馈队列调度算法'><span>3.3.5 多级反馈队列调度算法</span></h4><p><span>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法， 仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程 长度的抢占式调度算法都将无法使用。</span></p><p><span>而</span><strong><span>多级反馈队列调度算法</span></strong><span>则</span><strong><span>不必事先知道各种进程所需的执行时间</span></strong><span>，而且还可以满足各种类型进程的需要。</span></p><p><span>1.</span><strong><span>调度机制</span></strong></p><p><span>(1) 应</span><strong><span>设置多个就绪队列</span></strong><span>，并为各个队列赋予</span><strong><span>不同的优先级</span></strong><span>。</span><strong><span>第一个队列的优先级最高， 第二个队列次之</span></strong><span>，其余各队列的优先权逐个降低。</span></p><p><span>该算法赋予各个队列中进程执行</span><strong><span>时间片的大小</span></strong><span>也各不相同，在</span><strong><span>优先权愈高</span></strong><span>的队列中，</span><strong><span>时间片就愈小</span></strong><span>。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要 比第 i 个队列的时间片长一倍。</span></p><p><img src="img/3-3.png" referrerpolicy="no-referrer"></p><p><span>(2) 当一个</span><strong><span>新进程进入内存后</span></strong><span>，首先将它</span><strong><span>放入第一队列的末尾</span></strong><span>，</span><strong><span>按 FCFS 原则排队</span></strong><span>等待 调度。</span></p><p><span>当轮到该进程执行时，如它</span><strong><span>能在该时间片内完成</span></strong><span>，便可准备撤离系统；</span></p><p><span>如果它</span><strong><span>不能在一个时间片内</span></strong><span>完成，则</span><strong><span>转入第二队列的末尾</span></strong><span>，再同样地按 FCFS 原则等待调度执行；</span></p><p><span>如此下去，当一个长进程从第一队列依次降到第 n 队列后，在第 n 队列中便采取按时间片轮转的方式运行。 </span></p><p><span>(3) </span><strong><span>仅当第一队列空闲时</span></strong><span>，调度程序才</span><strong><span>调度第二队列</span></strong><span>中的进程运行；</span></p><p><span>仅当第 1～(i-1)队 列均空时，才会调度第 i 队列中的进程运行。</span></p><p><span>如果处理机正在第 i 队列中为某进程服务时， 又有新进程进入</span><strong><span>优先权较高的队列</span></strong><span>，则此时</span><strong><span>新进程将抢占正在运行进程的处理机</span></strong></p><p><span>2.</span><strong><span>算法性能</span></strong></p><p><span>如果规定第一队列的时间片略大于多数人机交互所需的处理时间，就能很好的满足各类用户的需要。</span></p><p><span>（1）终端型用户。这类用户提交的作业多为交互型作业，系统要能这些作业在第一队列规定的时间片内完成，就能使这类用户满意。</span></p><p><span>（2）短批处理作业用户。这类作业如果可在第一队列完成，就可以获得和终端型用户作业一样的响应时间，对于稍长的作业，只需在第二和第三队列完成，周转时间还是比较短。</span></p><p><span>（3）长批处理作业用户。对于长作业，将依次在n个队列中运行，最后再按轮转方式运行，用户不必担心长作业长期得不到处理。</span></p><h4 id='336-基于公平原则的调度算法'><span>3.3.6 基于公平原则的调度算法</span></h4><p><span>1.保证调度算法</span></p><p><span>如果在系统中有n个相同类型的进程同时运行，须保证每个进程都获得相同的处理机时间1/n。</span></p><p><span>在实施公平调度算法时系统必须具有如下功能：</span></p><p><span>① 跟踪计算</span><strong><span>每个进程自创建以来已经实际执行的处理时间</span></strong></p><p><span>② 计算每个进程</span><strong><span>应获得的处理机时间</span></strong><span>，即</span><strong><span>自创建以来的时间除以n</span></strong></p><p><span>③ 计算进程获得处理机时间的比率，即</span><strong><span>进程实际执行的处理时间</span></strong><span>和</span><strong><span>应获得的处理机时间之比</span></strong></p><p><span>④ </span><strong><span>比较</span></strong><span>各进程获得</span><strong><span>处理机时间的比率</span></strong></p><p><span>⑤ 调度程序应选择</span><strong><span>比率最小</span></strong><span>的进程将处理机分配给它，并让它</span><strong><span>一直运行下去</span></strong><span>，直到比率不为最小值为止。</span></p><p><span>2.公平分享调度算法</span></p><p><span>分配给每个进程相同的处理机时间对于各个进程来说是公平的，但是如果每个用户拥有的进程数不同，那对于用户来说是不公平的。</span></p><p><span>假设系统有2个用户，用户1启动了4个进程，用户2只启动1个进程，采用轮转法让每个进程轮流运行，那么对进程而言是公平的，但用户1和用户2得到的处理机时间分别为80%和20%，对于用户2而言就是不公平的。</span></p><p><span>在</span><strong><span>公平分享调度算法</span></strong><span>中，调度的公平性主要是针对用户而言，使所有用户能获得相同的处理机时间，或者所要求的时间比例。</span></p><p><span>例如系统中有两个用户，用户1有4个进程A,B,C,D，用户2有1个进程E。为保证两个用户能获得相同的处理机时间，则必须执行如下的强制调度序列：</span></p><p><span>A</span><span>	</span><span>E</span><span>	</span><span>B</span><span>	</span><span>E</span><span>	</span><span>C</span><span>	</span><span>E</span><span>	</span><span>D</span><span>	</span><span>E</span><span>	</span><span>A</span><span>	</span><span>E</span><span>	</span><span>B</span><span>	</span><span>E</span><span>	</span><span>C</span><span>	</span><span>E</span><span>	</span><span>D</span><span>	</span><span>E</span><span>	</span><span>......</span></p><p><span>如果希望用户1处理机时间：用户2处理机时间为2：1：</span></p><p><span>A</span><span>	</span><span>B</span><span>	</span><span>E</span><span>	</span><span>C</span><span>	</span><span>D</span><span>	</span><span>E</span><span>	</span><span>A</span><span>	</span><span>B</span><span>	</span><span>E</span><span>	</span><span>C</span><span>	</span><span>D</span><span>	</span><span>E</span><span>	</span><span>......</span></p><h3 id='34-实时调度'><span>3.4 实时调度</span></h3><h4 id='341-实现实时调度需要哪些条件'><span>3.4.1 实现实时调度需要哪些条件？</span></h4><ol start='' ><li><p><strong><span>提供必要的信息</span></strong></p><p><span>为了实现实时调度，系统应向调度程序提供有关任务的下述一些信息：</span></p><p><span>(1) </span><strong><span>就绪时间</span></strong><span>。这是该任务</span><strong><span>成为就绪状态的起始时间</span></strong><span>，在</span><strong><span>周期任务</span></strong><span>的情况下，它就是</span><strong><span>事先预知</span></strong><span>的一串时间序列；而在</span><strong><span>非周期任务</span></strong><span>的情况下，它也</span><strong><span>可能是预知的</span></strong></p><p><span>(2) </span><strong><span>开始截止时间和完成截止时间</span></strong><span>。对于典型的实时应用，只须知道开始截止时间，或者知道完成截止时间</span></p><p><span>(3) </span><strong><span>处理时间</span></strong><span>。这是指一个任务从开始执行直至完成所需的时间。在某些情况下，该时间也是系统提供的</span></p><p><span>(4) </span><strong><span>资源要求</span></strong><span>。这是指任务执行时所需的一组资源。</span></p><p><span>(5) </span><strong><span>优先级</span></strong><span>。如果某任务的开始截止时间已经错过，就会引起故障，则应为该任务赋予“绝对”优先级；如果开始截止时间的推迟对任务的继续运行无重大影响，则可为该任务赋予“相对”优先级，供调度程序参考</span></p></li><li><p><strong><span>系统处理能力强</span></strong></p></li><li><p><strong><span>采用抢占式调度机制</span></strong></p></li><li><p><strong><span>具有快速切换机制</span></strong><span>。为保证要求较高的硬实时任务能及时运行，在实时系统中还应具有快速切换机制，以保证能进行任务的快速切换。</span></p></li></ol><h4 id='342-实时调度算法的分类'><span>3.4.2 实时调度算法的分类</span></h4><p><span>1.非抢占式调度算法：些小型实时系统或要求不太严格 的实时控制系统</span></p><p><span>（1）非抢占式轮转调度算法：工业生产的群控系统</span></p><p><span>（2）非抢占式优先调度算法：实时系统中存在着要求较为严格(响应时间为数百毫秒)的任务</span></p><p><span>2.抢占式调度算法：在要求较严格的(响应时间为数十毫秒以下)的实时系统</span></p><p><span>（1）基于时钟中断的抢占式优先权调度算法</span></p><p><span>	</span><span>在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这时</span><strong><span>并不立即抢占</span></strong><span>当前任务的处理机，而是</span><strong><span>等到时钟中断</span></strong><span>到来时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先权任务</span></p><p><span>（2）立即抢占的优先权调度算法</span></p><p><span>	</span><span>在这种调度策略中，要求操作系统具有快速响应外部事件中断的能力。</span><strong><span>一旦出现外部中断</span></strong><span>，只要当前任务</span><strong><span>未处于临界区</span></strong><span>，便</span><strong><span>立即剥夺当前任务的执行</span></strong><span>，把处理机</span><strong><span>分配给请求中断的紧迫任务</span></strong></p><p><img src="img/3-4.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h4 id='343-最早截止时间优先edf算法⭐'><span>3.4.3 最早截止时间优先EDF算法⭐</span></h4><p><strong><span>⭐什么是最早截止时间优先算法?</span></strong></p><p><span>EDF是</span><strong><span>根据任务的截止时间确定任务的优先级</span></strong><span>，任务截止实际越早，优先级越高，具有最早截止时间的任务排在队首。调度程序总是选择就绪队列第一个任务，为它分配处理机。</span></p><p><span>1.</span><strong><span>非抢占调度方式用于非周期实时任务</span></strong></p><p><span>图示出了将该算法用于非抢占调度方式之例。该例中具有四个非周期任务，它们先 后到达。系统首先调度任务 1 执行，在任务 1 执行期间，任务 2、3 又先后到达。由于任务 3 的开始截止时间早于任务 2，故系统在任务 1 后将调度任务 3 执行。在此期间又到达作业 4，其开始截止时间仍是早于任务 2 的，故在任务 3 执行完后，系统又调度任务 4 执行，最后才调度任务 2 执行。</span></p><p><img src="img/3-5.png" referrerpolicy="no-referrer"></p><p><span>2.</span><strong><span>抢占式调度方式用于周期实时任务</span></strong></p><p><span>图示出了将最早截止时间优先算法用于抢占调度方式之例。在该例中有两个周期 性任务，任务 A 的周期时间为 20 ms，每个周期的处理时间为 10 ms；任务 B 的周期时间为 50 ms，每个周期的处理时间为 25 ms。图中的第一行示出了两个任务的到达时间、最后期 限和执行时间图。其中任务 A 的到达时间为 0、20、40、…；任务 A 的最后期限为 20、40、 60、…；任务 B 的到达时间为 0、50、100、…；任务 B 的最后期限为 50、100、150、…(注： 单位皆为 ms)。</span></p><p><img src="img/3-6.png" referrerpolicy="no-referrer"></p><p><span>为了说明通常的优先级调度不能适用于实时系统，该图特增加了第二和第三行。在第 二行中假定任务 A 具有较高的优先级，所以在 t = 0 ms 时，先调度 A1 执行，在 A1 完成后 (t = 10 ms)才调度 B1 执行；在 t = 20 ms 时，调度 A2 执行；在 t = 30 ms 时，A2 完成，又调 度 B1 执行；在 t = 40 ms 时，调度 A3 执行；在 t = 50 ms 时，虽然 A3 已完成，但 B1 已错过了它的最后期限，这说明了利用通常的优先级调度已经失败。第三行与第二行类似，只 是假定任务 B 具有较高的优先级。 第四行是采用最早截止时间优先算法的时间图。在 t = 0 时，A1 和 B1 同时到达，由于 A1 的截止时间比 B1 早，故调度 A1 执行；在 t = 10 时，A1 完成，又调度 B1 执行；在 t = 20 时，A2 到达，由于 A2 的截止时间比 B2 早，B1 被中断而调度 A2 执行；在 t = 30 时，A2 完成，又重新调度 B1 执行；在 t = 40 时，A3 又到达，但 B1 的截止时间要比 A3 早，仍应 让 B1 继续执行直到完成(t = 45)，然后再调度 A3 执行；在 t = 55 时，A3 完成，又调度 B2 执行。在该例中利用最早截止时间优先算法可以满足系统的要求。</span></p><h4 id='344-最低松弛度优先llf算法⭐'><span>3.4.4 最低松弛度优先LLF算法⭐</span></h4><p><strong><span>⭐什么是最低松弛度优先LLF算法?</span></strong></p><p><span>最低松弛度优先算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高，以使之优先执行。</span></p><p><span>在实现该算法时要求系统中有一个</span><strong><span>按松弛度排序的实时任务就绪队列</span></strong><span>，</span><strong><span>松弛度最低</span></strong><span>的任务排在队列</span><strong><span>最前面</span></strong><span>，调度程序总是选择就绪队列中的队首任务执行。</span></p><p>&nbsp;</p><p><span>该算法</span><strong><span>主要用于可抢占调度方式中</span></strong><span>。</span></p><p><span>假如在一个实时系统中，有两个周期性实时任务A和B，任务A要求每 20ms执行一次，执行时间为10ms；任务B只要求每 50 ms 执行一 次，执行时间为 25 ms。由此任务A和B每次必须完成的时间分别为：A1、A2、A3、… 和 B1、B2、B3、…。</span></p><p><img src="img/3-7.png" referrerpolicy="no-referrer"></p><ul><li><p><span>在刚开始时(t1 = 0)，A1 必须在 20 ms 时完成，而它本身运行又需 10 ms，可算出 </span><strong><span>A1 的 松弛度为 10 ms</span></strong><span>；</span></p><p><span>B1 必须在 50 ms 时完成，而它本身运行就需 25 ms，可算出 </span><strong><span>B1 的松弛度 为 25 ms</span></strong><span>，故调度程序应</span><strong><span>先调度 A1 执行</span></strong><span>。</span></p></li><li><p><span>在 t2 = 10 ms 时，A2 的松弛度可按下式算出：</span></p></li></ul><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n886" cid="n886" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="86.608ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 38280.7 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-4-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-4-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-4-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-4-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-4-TEX-N-200B" d=""></path><path id="MJX-4-TEX-N-34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path><path id="MJX-4-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-4-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-4-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-4-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-4-TEX-I-1D434"></use></g><g data-mml-node="mn" transform="translate(750,0)"><use data-c="32" xlink:href="#MJX-4-TEX-N-32"></use></g><g data-mml-node="mtext" transform="translate(1250,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(2102.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">松</text></g><g data-mml-node="mtext" transform="translate(2954.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">弛</text></g><g data-mml-node="mtext" transform="translate(3807.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">度</text></g><g data-mml-node="mo" transform="translate(4937.3,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="mtext" transform="translate(5993.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">必</text></g><g data-mml-node="mtext" transform="translate(6845.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">须</text></g><g data-mml-node="mtext" transform="translate(7697.8,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">完</text></g><g data-mml-node="mtext" transform="translate(8550.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">成</text></g><g data-mml-node="mtext" transform="translate(9402.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(10254.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(11329.5,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mtext" transform="translate(12329.7,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">其</text></g><g data-mml-node="mtext" transform="translate(13182.1,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">本</text></g><g data-mml-node="mtext" transform="translate(14034.5,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">身</text></g><g data-mml-node="mtext" transform="translate(14886.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">的</text></g><g data-mml-node="mtext" transform="translate(15739.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">运</text></g><g data-mml-node="mtext" transform="translate(16591.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">行</text></g><g data-mml-node="mtext" transform="translate(17444,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(18296.4,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="mo" transform="translate(19371,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mtext" transform="translate(20371.2,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">当</text></g><g data-mml-node="mtext" transform="translate(21223.6,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">前</text></g><g data-mml-node="mtext" transform="translate(22075.9,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">时</text></g><g data-mml-node="mtext" transform="translate(22928.3,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="852px" font-family="serif">间</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(23780.7,0)"><g data-mml-node="mo"><use data-c="200B" xlink:href="#MJX-4-TEX-N-200B"></use></g></g><g data-mml-node="mo" transform="translate(24058.5,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(25114.2,0)"><use data-c="34" xlink:href="#MJX-4-TEX-N-34"></use><use data-c="30" xlink:href="#MJX-4-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mi" transform="translate(26114.2,0)"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(26992.2,0)"><use data-c="1D460" xlink:href="#MJX-4-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(27683.5,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(28683.7,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-4-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mi" transform="translate(29683.7,0)"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(30561.7,0)"><use data-c="1D460" xlink:href="#MJX-4-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(31252.9,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(32253.1,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-4-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mi" transform="translate(33253.1,0)"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(34131.1,0)"><use data-c="1D460" xlink:href="#MJX-4-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(34877.9,0)"><use data-c="3D" xlink:href="#MJX-4-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(35933.7,0)"><use data-c="32" xlink:href="#MJX-4-TEX-N-32"></use><use data-c="30" xlink:href="#MJX-4-TEX-N-30" transform="translate(500,0)"></use></g><g data-mml-node="mi" transform="translate(36933.7,0)"><use data-c="1D45A" xlink:href="#MJX-4-TEX-I-1D45A"></use></g><g data-mml-node="mi" transform="translate(37811.7,0)"><use data-c="1D460" xlink:href="#MJX-4-TEX-I-1D460"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>A</mi><mn>2</mn><mtext>的</mtext><mtext>松</mtext><mtext>弛</mtext><mtext>度</mtext><mo>=</mo><mtext>必</mtext><mtext>须</mtext><mtext>完</mtext><mtext>成</mtext><mtext>时</mtext><mtext>间</mtext><mo>−</mo><mtext>其</mtext><mtext>本</mtext><mtext>身</mtext><mtext>的</mtext><mtext>运</mtext><mtext>行</mtext><mtext>时</mtext><mtext>间</mtext><mo>−</mo><mtext>当</mtext><mtext>前</mtext><mtext>时</mtext><mtext>间</mtext><mrow data-mjx-texclass="ORD"><mo>​</mo></mrow><mo>=</mo><mn>40</mn><mi>m</mi><mi>s</mi><mo>−</mo><mn>10</mn><mi>m</mi><mi>s</mi><mo>−</mo><mn>10</mn><mi>m</mi><mi>s</mi><mo>=</mo><mn>20</mn><mi>m</mi><mi>s</mi></math></mjx-assistive-mml></mjx-container></div></div><p><span>类似地，可算出 B1 的松弛度为 15 ms，故调度程序应选择 B2 运行。</span></p><ul><li><span>在 t3 = 30 ms 时， A2 的松弛度已减为 0(即 40 - 10 - 30)，而 B1 的松弛度为 15 ms(即 50 - 5 - 30)，于是调度程 序应抢占B1的处理机而调度 A2运行。</span></li><li><span>在 t4 = 40 ms 时，A3的松弛度为 10 ms(即 60 - 10 - 40)， 而 B1 的松弛度仅为 5 ms(即 50 - 5 - 40)，故又应重新调度 B1 执行。</span></li><li><span>在 t5 = 45 ms 时，B1 执行完成，而此时 A3 的松弛度已减为 5 ms(即 60 - 10 - 45)，而 B2 的松弛度为 30 ms (即 100 - 25 - 45)，于是又应调度 A3 执行。</span></li><li><span>在 t6 = 55 ms 时，任务 A 尚未进入第 4 周期，而任务B已进入第2周期，故再调度B2执行。</span></li><li><span>在 t7 = 70 ms 时，A4 的松弛度已减至 0 ms (即 80 - 10 - 70)，而 B2 的松弛度为 20 ms(即 100 - 10 - 70)，故此时调度又应抢占 B2 的处 理机而调度 A4 执行。</span></li></ul><p><img src="img/3-8.png" referrerpolicy="no-referrer"></p><h4 id='345-优先级倒置'><span>3.4.5 优先级倒置</span></h4><p><span>1.</span><strong><span>⭐什么是优先级倒置？请举例说明。</span></strong></p><p><span>优先级倒置就是</span><strong><span>高优先级进程被低优先级进程延迟或阻塞的现象</span></strong><span>。假如有3个独立的进程P1,P2,P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享的一个临界资源进行交互。假设P3最先执行，进行P(mutex)操作后，进入临界区CS-3。在t1时刻，P2就绪，因为它比P3优先级高，所以P2抢占了P3的处理机而执行。在t2时刻，P1就绪，因为它优先级比P2高，所以抢占了P2的处理机而运行。在t3时刻，P1执行P(mutex)，试图进入临界区CS-1，但因为相应的临界资源被P3占用，所以P1被阻塞，P2继续运行。直到时刻t4，P2结束运行，P3接着运行。直到时刻t5，P3退出临界区，并唤醒P1，由于P1比P3优先级高，故P1抢占了P3的处理机而运行。在上述例子中，P1和P3共享临界资源，导致出现了优先级低的进程比优先级高的进程阻塞了，又因为P2进程的存在延长了P1被阻塞的时间，</span><strong><span>被延长的时间是不可预知的</span></strong><span>，由此产生了优先级倒置现象。</span></p><p><span>2.</span><strong><span>⭐如何解决优先级倒置问题？</span></strong></p><p><span>一个比较使用的方法是建立在</span><strong><span>动态优先级继承</span></strong><span>基础上的。规定，当高优先级进程P1要进入临界区，去使用临界资源R时，如果已有一个低优先级的P3正在使用该资源，此时P1被阻塞，同时P3继承P1的优先级，直到P3退出临界区。这样一来，即使有比P3优先级高比P1优先级低的进程P2，也不会延长P1被阻塞的时间。</span></p><h3 id='35--⭐死锁概述'><span>3.5  ⭐死锁概述</span></h3><h4 id='351-死锁的定义'><span>3.5.1 死锁的定义</span></h4><p><span>如果</span><strong><span>一组进程中的每一个进程</span></strong><span>都在</span><strong><span>等待</span></strong><span>仅由</span><strong><span>该组中的其它进程</span></strong><span>才能</span><strong><span>引发的事件</span></strong><span>，那么这组进程是死锁的，</span></p><h4 id='352⭐产生死锁的必要条件'><span>3.5.2⭐产生死锁的必要条件</span></h4><ol start='' ><li><strong><span>互斥条件</span></strong><span>。指进程对于所分配到的资源进行排它性使用，即在一段时间内，某资源只能被一个进程占用。</span></li><li><strong><span>请求和保持条件</span></strong><span>。进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占用，请求进程被阻塞，但是保持已获得的资源。</span></li><li><strong><span>不可抢占条件</span></strong><span>。进程已获得的资源在未使用完之前不能被抢占，只能在使用完之后自己释放。</span></li><li><strong><span>循环等待条件</span></strong><span>。发生死锁时，必然存在一个进程-资源的循环链，即P0等待P1占用的资源，P1等待P2占用的资源，......，Pn等待P0占用的资源。</span></li></ol><h4 id='353-如何处理死锁'><span>3.5.3 如何处理死锁？</span></h4><ol start='' ><li><strong><span>预防死锁</span></strong><span>。该方法是通过设置某些限制条件，</span><strong><span>去破坏产生死锁的四个必要条件中的一个或几个条件</span></strong><span>，来预防发生死锁。</span></li><li><strong><span>避免死锁</span></strong><span>。该方法是</span><strong><span>在资源的动态分配过程中</span></strong><span>，用某种方法去</span><strong><span>防止系统进入不安全状态</span></strong><span>，从而避免发生死锁。</span></li><li><strong><span>检测死锁</span></strong><span>。这种方法</span><strong><span>允许系统在运行过程中发生死锁</span></strong><span>。但通过系统所设置的检测机构</span><strong><span>及时地检测出死锁的发生</span></strong><span>，并精确地确定与死锁有关的进程和资源； 然后，采取适当措施， 从系统中将已发生的死锁清除掉。</span></li><li><strong><span>解除死锁</span></strong><span>。当检测到系统中</span><strong><span>已发生死锁时</span></strong><span>，须将进程从死锁状态中解脱出来。常用的实施方法是</span><strong><span>撤消或挂起一些进程</span></strong><span>，以便</span><strong><span>回收一些资源</span></strong><span>，再将这些资源</span><strong><span>分配给已处于阻塞状态的进程</span></strong><span>，使之转为就绪状态，以继续运行。</span></li></ol><h3 id='36-预防死锁'><span>3.6 预防死锁</span></h3><p><strong><span>为什么不能破坏互斥条件？</span></strong></p><p><strong><span>因为互斥是非共享设备所必须的，不仅不能破坏，还应该加以保证。</span></strong></p><h4 id='361-破坏请求和保持条件'><span>3.6.1 破坏&quot;请求和保持条件&quot;</span></h4><p><span>可以由两种协议实现。</span></p><p><span>1.第一种协议</span></p><p><span>所有进程在</span><strong><span>开始运行之前</span></strong><span>，必须</span><strong><span>一次性的申请</span></strong><span>其在整</span><strong><span>个运行过程中所需要的全部资源</span></strong><span>。在进程运行期间，不能再提出资源请求，从而破坏了请求和保持条件。</span></p><p><span>优点是简单，容易实现且安全。</span></p><p><span>缺点明显：</span></p><p><span>（1）</span><strong><span>资源被严重浪费，大大降低了资源利用率</span></strong><span>。进程在开始运行时就一次性的占用了整个运行过程需要的资源，但有些资源仅在运行初期或最后才被使用，甚至根本不使用。</span></p><p><span>（2）</span><strong><span>会使进程经常发生饥饿现象</span></strong><span>。因为仅当进程获得全部资源后才能运行，这样可能会有一些资源只在进程运行到最后才被用到，而造成等待这些资源的进程迟迟不能开始运行。</span></p><p><span>2.第二种协议</span></p><p><span>该协议允许一个进程只获得运行初期所需的资源后就开始运行。运行期间，进程再逐步释放已分配的且用完的资源，然后再请求新的资源。</span></p><h4 id='362-破坏不可抢占条件'><span>3.6.2 破坏&quot;不可抢占条件&quot;</span></h4><p><span>当一个进程已经保持了某些不可被抢占资源，再提出新的资源请求不能被满足时，它必须先释放已经保持的所有资源，等以后需要时再重新申请。这意味着进程已占用的资源会被暂时释放，即被抢占了，从而破坏了不可抢占条件。</span></p><h4 id='363-破坏循环等待条件'><span>3.6.3 破坏&quot;循环等待条件&quot;</span></h4><p><span>这种方法中规定，系统</span><strong><span>将所有资源按类型进行线性排队</span></strong><span>，并赋予不同的序号。所有进程对资源的请求必须</span><strong><span>严格按照资源序号递增的次序提出</span></strong><span>。当某个进程已经请求到序号高的资源，又想请求序号低的资源时，必须</span><strong><span>先释放所有具有相同和更高序号的资源</span></strong><span>，然后才能申请序号低的资源。这样，在所形成的资源分配图中，不可能再出现环路，因而破坏了“循环等待”条件。</span></p><p><span>但也存在下述严重问题： </span></p><ul><li><span>首先是为系统中各类资源所分配的序号必须相对稳定，这就限制了新类型设备的增加。</span></li><li><span>其次，尽管在为资源的类型分配序号时，已经考虑到大多数作业在实际使用这些资源 时的顺序，但也经常会发生这种情况：即作业(进程)使用各类资源的顺序与系统规定的顺序 不同，造成对资源的浪费。例如，某进程先用磁带机，后用打印机，但按系统规定，该进 程应先申请打印机而后申请磁带机，致使先获得的打印机被长时间闲置。 </span></li><li><span>第三，为方便用户，系统对用户在编程时所施加的限制条件应尽量少。然而这种按规定次序申请的方法，必然会限制用户简单、自主地编程。</span></li></ul><h3 id='37-避免死锁'><span>3.7 避免死锁</span></h3><h4 id='371-系统安全状态'><span>3.7.1 系统安全状态</span></h4><p><span>在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待。</span></p><p><span>1.</span><strong><span>安全状态</span></strong></p><p><span>所谓安全状态，是指系统能按某种进程顺序(P1，P2，…，Pn)，来为每个进程 Pi分配其所需资源，直至</span><strong><span>满足每个进程对资源的最大需求</span></strong><span>， 使每个进程都可顺利地完成。如果系统</span><strong><span>无法找到这样一个安全序列</span></strong><span>，则称系统处于不安全状态。</span></p><p><span>2.安全状态之例</span></p><p><span>我们通过一个例子来说明安全性。假定系统中有三个进程 P1、P2和 P3，共有 12 台磁带 机。进程 P1总共要求 10 台磁带机，P2和 P3分别要求 4 台和 9 台。假设在 T0时刻，进程 P1、 P2和 P3已分别获得 5 台、2 台和 2 台磁带机，尚有 3 台空闲未分配，如下表所示：</span></p><p><img src="img/3-9.png" referrerpolicy="no-referrer"></p><p><span>经分析发现，在 T0时刻系统是安全的，因为这时存在一个安全序列〈P2，P1，P3〉，即 只要系统按此进程序列分配资源，就能使每个进程都顺利完成。例如，将剩余的磁带机取 2 台分配给 P2，使之继续运行，待 P2完成，便可释放出 4 台磁带机，于是可用资源增至 5 台； 以后再将这些全部分配给进程 P1，使之运行，待 P1 完成后，将释放出 10 台磁带机，P3 便 能获得足够的资源，从而使 P1、P2、P3每个进程都能顺利完成。</span></p><p><span>3.由安全状态向不安全状态的转换</span></p><p><span>如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如，在 T0时刻以后，P3又请求 1 台磁带机，若此时系统把剩余 3 台中的 1 台分配给 P3，则系统便 进入不安全状态。因为此时也无法再找到一个安全序列，例如，把其余的 2 台分配给 P2， 这样，在 P2完成后只能释放出 4 台，既不能满足 P1尚需 5 台的要求，也不能满足 P3尚需 6 台的要求，致使它们都无法推进到完成，彼此都在等待对方释放资源，即陷入僵局，结果 导致死锁。类似地，如果我们将剩余的 2 台磁带机先分配给 P1或 P3，也同样都无法使它们 推进到完成，因此，从给 P3分配了第 3 台磁带机开始，系统便又进入了不安全状态。由此 可见，在 P3请求资源时，尽管系统中尚有可用的磁带机，但却不能分配给它，必须让 P3一 直等待到 P1和 P2完成，释放出资源后再将足够的资源分配给 P3，它才能顺利完成。</span></p><h4 id='372-利用银行家算法避免死锁⭐'><span>3.7.2 利用银行家算法避免死锁⭐</span></h4><p><span>1.</span><strong><span>银行家算法中的数据结构</span></strong></p><p><span>(1) 可利用资源向量 Available。这是一个含有 m 个元素的数组，其中的每一个元素代 表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值 随该类资源的分配和回收而动态地改变。如果 Available[j]=K，则表示系统中现有 R j类资源 K 个。</span></p><p><span> (2) 最大需求矩阵 Max。这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个 进程对 m 类资源的最大需求。如果 Max[i,j]=K，则表示进程 i 需要 Rj 类资源的最大数目 为 K。 </span></p><p><span>(3) 分配矩阵 Allocation。这也是一个 n×m 的矩阵，它定义了系统中每一类资源当前已 分配给每一进程的资源数。如果 Allocation[i,j]=K，则表示进程 i 当前已分得 R j类资源的数 目为 K。</span></p><p><span> (4) 需求矩阵 Need。这也是一个 n×m 的矩阵，用以表示每一个进程尚需的各类资源数。 如果 Need[i,j]=K，则表示进程 i 还需要 R j类资源 K 个，方能完成其任务。 上述三个矩阵间存在下述关系：</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n970" cid="n970" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="38.247ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 16905 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-5-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-5-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path><path id="MJX-5-TEX-I-1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path><path id="MJX-5-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path><path id="MJX-5-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-5-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-5-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path><path id="MJX-5-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path><path id="MJX-5-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-5-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-5-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-5-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-5-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-5-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-5-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-5-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-5-TEX-I-1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path><path id="MJX-5-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-5-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D441" xlink:href="#MJX-5-TEX-I-1D441"></use></g><g data-mml-node="mi" transform="translate(888,0)"><use data-c="1D452" xlink:href="#MJX-5-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(1354,0)"><use data-c="1D452" xlink:href="#MJX-5-TEX-I-1D452"></use></g><g data-mml-node="mi" transform="translate(1820,0)"><use data-c="1D451" xlink:href="#MJX-5-TEX-I-1D451"></use></g><g data-mml-node="mo" transform="translate(2340,0)"><use data-c="5B" xlink:href="#MJX-5-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(2618,0)"><use data-c="1D456" xlink:href="#MJX-5-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(2963,0)"><use data-c="2C" xlink:href="#MJX-5-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(3407.7,0)"><use data-c="1D457" xlink:href="#MJX-5-TEX-I-1D457"></use></g><g data-mml-node="mo" transform="translate(3819.7,0)"><use data-c="5D" xlink:href="#MJX-5-TEX-N-5D"></use></g><g data-mml-node="mo" transform="translate(4375.4,0)"><use data-c="3D" xlink:href="#MJX-5-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(5431.2,0)"><use data-c="1D440" xlink:href="#MJX-5-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(6482.2,0)"><use data-c="1D44E" xlink:href="#MJX-5-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(7011.2,0)"><use data-c="1D465" xlink:href="#MJX-5-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(7583.2,0)"><use data-c="5B" xlink:href="#MJX-5-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(7861.2,0)"><use data-c="1D456" xlink:href="#MJX-5-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(8206.2,0)"><use data-c="2C" xlink:href="#MJX-5-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(8650.9,0)"><use data-c="1D457" xlink:href="#MJX-5-TEX-I-1D457"></use></g><g data-mml-node="mo" transform="translate(9062.9,0)"><use data-c="5D" xlink:href="#MJX-5-TEX-N-5D"></use></g><g data-mml-node="mo" transform="translate(9563.1,0)"><use data-c="2212" xlink:href="#MJX-5-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(10563.3,0)"><use data-c="1D434" xlink:href="#MJX-5-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(11313.3,0)"><use data-c="1D459" xlink:href="#MJX-5-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(11611.3,0)"><use data-c="1D459" xlink:href="#MJX-5-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(11909.3,0)"><use data-c="1D45C" xlink:href="#MJX-5-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(12394.3,0)"><use data-c="1D450" xlink:href="#MJX-5-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(12827.3,0)"><use data-c="1D44E" xlink:href="#MJX-5-TEX-I-1D44E"></use></g><g data-mml-node="mi" transform="translate(13356.3,0)"><use data-c="1D461" xlink:href="#MJX-5-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(13717.3,0)"><use data-c="1D456" xlink:href="#MJX-5-TEX-I-1D456"></use></g><g data-mml-node="mi" transform="translate(14062.3,0)"><use data-c="1D45C" xlink:href="#MJX-5-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(14547.3,0)"><use data-c="1D45B" xlink:href="#MJX-5-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(15147.3,0)"><use data-c="5B" xlink:href="#MJX-5-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(15425.3,0)"><use data-c="1D456" xlink:href="#MJX-5-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(15770.3,0)"><use data-c="2C" xlink:href="#MJX-5-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(16215,0)"><use data-c="1D457" xlink:href="#MJX-5-TEX-I-1D457"></use></g><g data-mml-node="mo" transform="translate(16627,0)"><use data-c="5D" xlink:href="#MJX-5-TEX-N-5D"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo stretchy="false">[</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">]</mo></math></mjx-assistive-mml></mjx-container></div></div><p><span>2.</span><strong><span>⭐银行家算法</span></strong><span> </span></p><p><span>设 Request i是进程 Pi的请求向量，如果 </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Requesti[j] = K</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p><span>，表示进程 P i需要 K 个 R j类型 的资源。当 P i发出资源请求后，系统按下述步骤进行检查： </span></p><p><span>(1) 如果</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Request i[j] ≤ Need[i,j]</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p><span>，便转向步骤(2)否则认为出错，因为它所需要的资源 数已超过它所宣布的最大值。 </span></p><p><span>(2) 如果 </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Requesti [j] ≤ Available[j]</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p><span>，便转向步骤(3)；否则，表示尚无足够资源，Pi 须 等待。</span></p><p><span> (3) 系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Available[j] = Available[j]-Request i[j]； </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Allocation[i,j] = Allocation[i,j]+Request i[j]；</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> Need[i,j] = Need[i,j]-Request i[j]；</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 130px;"></div><div class="CodeMirror-gutters" style="display: none; height: 130px;"></div></div></div></pre><p><span>(4) 系统</span><strong><span>执行安全性算法</span></strong><span>，检查此次资源分配后系统是否处于安全状态。若安全，才</span><strong><span>正式将资源分配给进程 Pi</span></strong><span>，以完成本次分配；否则，将本次的</span><strong><span>试探分配作废</span></strong><span>，恢复原来的资源分配状态，让进程 Pi等待。</span></p><p><span>3.⭐</span><strong><span>安全性算法</span></strong></p><p><span>系统所执行的安全性算法可描述如下： </span></p><p><span>(1) 设置两个向量： </span></p><ul><li><span>① 工作向量 Work，它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全算法开始时，Work:=Available。 </span></li><li><span>② Finish，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做 Finish[i]:=false；当有足够资源分配给进程时，再令 Finish[i]:=true。</span></li></ul><p><span> (2) 从进程集合中找到一个能满足下述条件的进程： </span></p><ul><li><p><span>① </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Finish[i]=false；</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p>&nbsp;</p></li><li><p><span>② </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Need[i,j]≤Work[j]；</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre></li><li><p><span>若找到，执行步骤(3)，否则，执行步骤(4)</span></p></li></ul><p><span>(3) 当进程 Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应 执行： </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Work[j] = Work[j]+Allocation[i,j]； </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Finish[i] = true； </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">go to step 2；</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 130px;"></div><div class="CodeMirror-gutters" style="display: none; height: 130px;"></div></div></div></pre><p><span> (4) 如果</span><strong><span>所有进程的 Finish[i] = true 都满足</span></strong><span>，则表示系统处于</span><strong><span>安全状态</span></strong><span>；否则，系统处于 不安全状态。</span></p><p><span>4.</span><strong><span>银行家算法之例</span></strong></p><p><span>假定系统中有五个进程{P0，P1，P2，P3，P4}和三类资源{A，B，C}，各种资源的数量 分别为 10、5、7，在 T0时刻的资源分配情况如图所示。</span></p><p><img src="img/3-10.png" referrerpolicy="no-referrer"></p><p><span>(1) T0时刻的安全性：利用安全性算法对 T0时刻的资源分配情况进行分析(见图 3-17 所 示)可知，在 T0时刻存在着一个安全序列{P1，P3，P4，P2，P0}，故系统是安全的。</span></p><p><img src="img/3-11.png" referrerpolicy="no-referrer"></p><p><span>(2) P1请求资源：P1发出请求向量 Request1(1，0，2)，系统按银行家算法进行检查： </span></p><ul><li><p><span>① </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Request1(1，0，2) ≤ Need1(1，2，2) </span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p>&nbsp;</p></li><li><p><span>② </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Request1(1，0，2) ≤ Available1(3，3，2) </span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p>&nbsp;</p></li><li><p><span>③ 系统先假定可为 P1分配资源，并修改 Available，Allocation1和 Need1向量，由此形 成的资源变化情况如图 3-16 中的圆括号所示</span></p></li><li><p><span>④ 再利用安全性算法检查此时系统是否安全。如图 3-18 所示。</span></p></li></ul><p><img src="img/3-12.png" referrerpolicy="no-referrer"></p><p><span>由所进行的安全性检查得知，可以找到一个安全序列{P1，P3，P4，P2，P0}。因此，系 统是安全的，可以立即将 P1所申请的资源分配给它。 </span></p><p><span>(3) P4请求资源：P4发出请求向量 Request4(3，3，0)，系统按银行家算法进行检查： </span></p><ul><li><p><span>① </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Request4(3，3，0) ≤ Need4(4，3，1)；</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p><span> </span></p></li><li><p><span>② </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Request4(3，3，0) ≤ Available(2，3，0)</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p><span>，让 P4等待。 </span></p></li></ul><p><span>(4) P0请求资源：P0发出请求向量 Requst0(0，2，0)，系统按银行家算法进行检查： </span></p><ul><li><p><span>① </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Request0(0，2，0) ≤ Need0(7，4，3)；</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p>&nbsp;</p></li><li><p><span>② </span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang=""><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 11px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Request0(0，2，0)≤Available(2，3，0);</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p>&nbsp;</p></li><li><p><span>③ 系统暂时先假定可为 P0分配资源，并修改有关数据，如图 3-19 所示。</span></p></li></ul><p><img src="img/3-13.png" referrerpolicy="no-referrer"></p><p><span>(5) 进行安全性检查：可用资源 Available(2，1，0)已不能满足任何进程的需要，故系统进入不安全状态，此时系统不分配资源。 </span></p><p>&nbsp;</p><p><span>问题：如果在银行家算法中，把 P0发出的请求向量改为 Request0(0，1，0)，系统是否能将资源分配给它？</span></p><p>&nbsp;</p><h3 id='38-死锁的检测和解除'><span>3.8 死锁的检测和解除</span></h3><h4 id='381-死锁的检测'><span>3.8.1 死锁的检测</span></h4><p><span>1.</span><strong><span>资源分配图</span></strong></p><p><span>系统死锁可利用资源分配图来描述。该图是由一组结点 N 和一组边 E 所组成的一个对偶 G=(N1E)，它具有下述形式的定义和限制： </span></p><p><span>(1) 把 N 分为两个互斥的子集，即一组进程结点 P={p1，p2，…，pn}和一组资源结点 R={r1，r2，…，rn}，N=P∪R。在图 3-20 所示的例子中，P={p1，p2}，R={r1，r2}， N={r1，r2}∪{p1，p2}。 </span></p><p><span>(2) 凡属于E中的一个边 e∈E，都连接着 P 中的一个结点和 R 中的一个结点。</span></p><ul><li><span>e={pi，rj} 是资源请求边，由进程 pi指向资源 rj，它表示进程 pi请求一个单位的 rj资源。</span></li><li><span>e={rj，pi}是资源分配边，由资源 rj指向进程 pi，它表示把一个单位的资源 rj分配给进程 pi。</span></li><li><span>图 3-13 中示出了两个请求边和两个分配边，即 E={(p1，r2)，(r2，p2)，(p2，r1)，(r1，p1)}。 </span></li><li><span>我们用圆圈代表一个进程，用方框代表一类资源。由于一种类型的资源可能有多个，我们用 方框中的一个点代表一类资源中的一个资源。</span></li><li><span>此时，请求边是由进程指向方框中的 rj，而分配边则应始于方框中的一个点。</span></li><li><span>图中，p1 进程已经分得了两个 r1 资源， 并又请求一个 r2 资源；p2 进程分得了一个 r1 和一 个 r2资源，并又请求 r1资源。</span></li></ul><p><img src="img/3-14.png" referrerpolicy="no-referrer"></p><p><span>2.死锁定理</span></p><p><span>我们可以利用把资源分配图加以简化的方法(图 3-21)，来检测当系统处于 S 状态时是否 为死锁状态。简化方法如下：</span></p><p><span> (1) 在资源分配图中，找出一个既不阻塞又非独立的进程结点 Pi。在顺利的情况下，Pi 可获得所需资源而继续运行，直至运行完毕，再释放其所占有的全部资源，这相当于消去 pi所求的请求边和分配边，使之成为孤立的结点。在图 3-21(a)中，将 p1的两个分配边和一 个请求边消去，便形成图(b)所示的情况。</span></p><p><img src="img/3-15.png" referrerpolicy="no-referrer"></p><p><span>(2) p1释放资源后，便可使 p2获得资源而继续运行，直至 p2完成后又释放出它所占有 的全部资源，形成图(c)所示的情况。</span></p><p><span> (3) 在进行一系列的简化后，若能消去图中所有的边，使所有的进程结点都成为孤立结 点，则称该图是可完全简化的；若不能通过任何过程使该图完全简化，则称该图是不可完 全简化的。</span></p><p><strong><span>死锁定理</span></strong><span>：</span><strong><span>当且仅当 S 状态</span></strong><span>的</span><strong><span>资源分配图</span></strong><span>是</span><strong><span>不可完全简化</span></strong><span>的。（S 为死锁状态的充分条件）</span></p><h4 id='382-死锁的解除'><span>3.8.2 死锁的解除</span></h4><p><span>常采用解除死锁的两 种方法是： </span></p><p><span>(1) </span><strong><span>剥夺资源</span></strong><span>。从其它进程</span><strong><span>剥夺足够数量的资源给死锁进程</span></strong><span>，以解除死锁状态。</span></p><p><span> (2) </span><strong><span>撤消进程</span></strong><span>。</span><strong><span>按照某种顺序逐个地撤消进程</span></strong><span>，</span><strong><span>直至有足够的资源可用</span></strong><span>，使死锁状态消除为止。</span></p><p><span>在出现死锁时，可采用各种策略来撤消进程。例如，为解除死锁状态所需撤消的进程数目最小；或者，撤消进程所付出的代价最小等。</span></p><p>&nbsp;</p><h2 id='4存储器管理'><span>4.存储器管理</span></h2><h3 id='41-存储器的层次结构'><span>4.1 存储器的层次结构</span></h3><h4 id='411-存储器的多层结构'><span>4.1.1 存储器的多层结构</span></h4><p><span>存储层次至少应具有三级：</span><strong><span>最高层为CPU寄存器，中间为主存，最底层是辅存</span></strong></p><p><img src="img/4-1.jpg" referrerpolicy="no-referrer"></p><h4 id='412-各类存储器的基本作用'><span>4.1.2 各类存储器的基本作用</span></h4><ol start='' ><li><p><span>寄存器：</span><strong><span>寄存器和主存储器</span></strong><span>又被称为可执行存储器，寄存器</span><strong><span>具有与处理机相同的速度</span></strong><span>，完全能与CPU协调工作，但价格却十分昂贵，因此容量不可能做得很大。 </span></p></li><li><p><span>主存储器：主存储器</span><strong><span>简称内存或主存</span></strong><span>，</span><strong><span>用于保存进程运行时的程序和数据。</span></strong></p></li><li><p><span>高速缓存：它是</span><strong><span>介于寄存器和主存储器之间</span></strong><span>的存储器，</span><strong><span>主要用于备份主存中较常用的数据</span></strong><span>（局部性原理）），</span><strong><span>以减少处理机对主存储器的访问次数</span></strong><span>，这样可</span><strong><span>大幅度地提高程序执行速度</span></strong><span>，访问速度快于主存储器</span></p><p><span>局部性原理：程序在执行时呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分</span></p></li><li><p><span>磁盘缓存：由于</span><strong><span>磁盘的I/O速度远低于对主存的访问速度</span></strong><span>，</span><strong><span>为了缓和两者之间在速度上的不匹配</span></strong><span>，而设置了磁盘缓存。</span></p><p><span>作业： </span><strong><span>暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数</span></strong><span>。</span></p><p><span>但</span><strong><span>磁盘缓存与高速缓存不同</span></strong><span>，它本身并不是一种实际存在的存储器，而是</span><strong><span>利用主存中的部分存储空间暂时存放从磁盘中读出(或写入)的信息</span></strong><span>，</span><strong><span>主存也可以看作是辅存的高速缓存</span></strong></p></li></ol><p>&nbsp;</p><h3 id='42-程序的装入与链接'><span>4.2 程序的装入与链接</span></h3><p><span>　用户程序要在系统中运行，通常都要经过以下几个步骤：</span></p><p><img src="img/4-2.jpg" referrerpolicy="no-referrer"></p><h4 id='421-程序的装入'><span>4.2.1 程序的装入</span></h4><ol start='' ><li><p><span>绝对装入方式：</span></p><p><strong><span>当计算机系统很小</span></strong><span>，且仅能运行单道程序时，</span><strong><span>完全有可能知道程序将驻留在内存的什么位置</span></strong><span>，此时可以采用绝对装入方式。</span><strong><span>用户程序经编译后，将产生绝对地址(即物理地址)的目标代码。</span></strong><span> </span></p></li><li><p><span>可重定位装入方式</span></p><p><strong><span>绝对装入方式</span></strong><span>只能将目标模块装入到内存中事先指定的位置，这</span><strong><span>只适用于单道程序环境</span></strong><span>。</span></p><p><span>而在</span><strong><span>多道程序环境下</span></strong><span>，编译程序</span><strong><span>不可能预知经编译后所得到的目标模块应放在内存的何处</span></strong><span>，而应采用可重定位装入方式，</span><strong><span>它可以根据内存的具体情况将装入模块装入到内存的适当位置。</span></strong></p><p>&nbsp;</p><p><span>对于用户程序编译所形成的若干个目标模块，它们的</span><strong><span>起始地址（即逻辑地址）通常都是从0开始的</span></strong><span>，</span><strong><span>程序中的其它地址也都是相对于起始地址计算的。</span></strong></p><p><span>注意：在采用可重定位装入程序将</span><strong><span>装入模块*</span></strong><span>*装入内存后</span><strong><span>，会使装入模块中的所有逻辑地址与实际装入内存后的物理地址不同，</span></strong><span>需要修改用户程序中的数据地址和指令地址。**</span></p><p><span>通常，把在装入时对目标程序中指令和数据地址的修改过程称为重定位。</span></p><p><img src="img/4-3.jpg" referrerpolicy="no-referrer"></p></li><li><p><span>动态运行时装入方式</span></p><p><strong><span>可重定位装入方式</span></strong><span>可将</span><strong><span>装入模块装入到内存中任何允许的位置</span></strong><span>，故可用于多道程序环境。</span><strong><span>但该方式并不允许程序运行时在内存中移动位置。</span></strong></p><p><span> 然而实际情况是，</span><strong><span>在运行过程中程序在内存中的位置可能经常变化</span></strong><span>，例如在具有对换功能的系统中，一个进程可能北多次换入换出，每次换入后的位置通常是不同的，这种情况下就应该采用动态运行时装入方式。</span></p><p><span>实现：动态运行时装入方式在把装入模块装入内存后，</span><strong><span>等到程序真正要执行时才把装入模块的逻辑地址转换为物理地址</span></strong><span>，因此，</span><strong><span>装入内存后的所有地址</span></strong><span>仍然是</span><strong><span>逻辑地址</span></strong><span>。</span></p></li></ol><h4 id='422-程序的链接'><span>4.2.2 程序的链接</span></h4><p><strong><span>链接</span></strong><span>程序的功能是把编译后产生的一组</span><strong><span>目标模块</span></strong><span>以及它们需要的库函数</span><strong><span>装配</span></strong><span>成一个完整的</span><strong><span>装入模块</span></strong><span>。</span></p><ol start='' ><li><p><span>静态链接</span></p><p><strong><span>在程序运行之前</span></strong><span>，先将各目标模块及它们所需的库函数</span><strong><span>链接成一个完整的装配模块，以后不再拆开</span></strong><span>。</span></p><p><span>在将这几个目标模块装配成一个装入模块时，须解决以下两个问题： </span>
<span> 　(1) 对相对地址进行修改。 M-1 =&gt; L+M-1</span>
<span> 　(2) 变换外部调用符号。CALL B =&gt; JSR &quot;L&quot;</span></p><p><img src="img/4-4.jpg" referrerpolicy="no-referrer"></p></li><li><p><span>装入时动态链接</span></p><p><span>这是指将用户源程序编译后所得到的一组</span><strong><span>目标模块</span></strong><span>，</span><strong><span>在装入内存时</span></strong><span>，采用</span><strong><span>边装入边链接的链接方式</span></strong><span>。即在装入一个目标模块时，</span><strong><span>若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存</span></strong><span>，还要</span><strong><span>修改</span></strong><span>目标模块中的</span><strong><span>相对地址</span></strong><span>。</span></p><p><span>优点：</span>
<span> 　</span><strong><span>(1) 便于修改和更新。</span></strong><span>由于各目标模块是分开存放的，所以便于修改和更新各目标模块</span>
<span> 　</span><strong><span>(2) 便于实现对目标模块的共享</span></strong><span>。OS很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享。</span></p></li><li><p><span>运行时动态链接</span></p><p><span>在许多情况下，应用程序在运行时，每次要运行的模块可能是不相同的。但由于事先无法知道本次要运行哪些模块，直接的办法是将所有可能要运行到的模块全部都装入内存，并在装入时全部链接在一起，这是低效的，因为往往会有部分目标模块根本就不运行。</span></p><p><span>比较典型的例子是作为错误处理用的目标模块，如果程序在整个运行过程中都不出现错误，则显然就不会用到该模块。</span></p><p><strong><span>运行时动态链接是，将对某些模块的链接推迟到程序执行时才进行。</span></strong><span>具体来说，是程序在执行过程中，发现一个被调用模块未装入内存时，立即由OS去找到该模块并装入内存，链接到调用者的模块上。</span></p><p><span>优点：在执行过程中未被用到的目标模块就不会被调入内存和链接到装入模块，这样不仅能</span><strong><span>加快程序的装入速度</span></strong><span>，而且可以</span><strong><span>节省大量内存空间。</span></strong></p></li></ol><h3 id='43-连续分配存储管理方式-⭐'><span>4.3 连续分配存储管理方式 ⭐</span></h3><p><span>四种连续分配方式：</span><strong><span>单一连续分配、固定分区分配、动态分区分配、动态可重定位分区分配</span></strong></p><h4 id='431-单一连续分配'><span>4.3.1 单一连续分配</span></h4><p><span>　在</span><strong><span>单道程序环境下，</span></strong><span>当时的存储器管理方式是</span><strong><span>把内存分为系统区和用户区</span></strong><span>两部分，系统区仅提供给OS使用，它通常是放在内存的低址部分。而在用户区内存中，</span><strong><span>仅装有一道用户程序，即整个内存的用户空间由该程序独占。</span></strong><span>这样的存储器分配方式被称为单一连续分配方式</span></p><h4 id='432-固定分区分配'><span>4.3.2 固定分区分配</span></h4><p><span>将用户空间划分为若干各固定大小的区域，每个分区只装入一道作业。</span></p><p><strong><span>划分分区的方法：</span></strong>
<span> 　可用下述两种方法将内存的用户空间划分为若干个固定大小的分区： </span>
<span> 　(1) </span><strong><span>分区大小相等(</span></strong><span>指所有的内存分区大小相等)：缺乏灵活性，当程序太小会造成内存空间的浪费，程序太大又不足以载入程序。</span>
<span> 　(2) </span><strong><span>分区大小不等</span></strong><span>：可根据程序大小，为之分配适当的分区</span></p><p><strong><span>内存分配：</span></strong></p><p><span>为了便于内存分配，通常</span><strong><span>将分区按其大小进行排队</span></strong><span>，并为之</span><strong><span>建立一张分区使用表</span></strong><span>，其中各表项</span><strong><span>包括每个分区的起始地址、大小及状态</span></strong><span>(是否已分配)</span></p><p><img src="img/4-5.jpg" referrerpolicy="no-referrer"></p><p><span>固定分区分配是最早可用于多道程序系统的存储管理方式。</span></p><h4 id='433-动态分区分配'><span>4.3.3 动态分区分配</span></h4><p><span>动态分区分配又称为可变分区分配，</span><strong><span>它是根据进程的实际需要，动态地为之分配内存空间。</span></strong></p><ol start='' ><li><p><strong><span>动态分区分配中的数据结构</span></strong><span> </span></p><p><span>常用的数据结构有以下两种形式：</span></p><p><span>① 空闲分区表，在系统中设置一张空闲分区表，</span><strong><span>用于记录每个空闲分区的情况</span></strong><span>。每个空闲分区占一个表目，表目中包括分区号、分区大小和分区始址等数据项</span></p><p><img src="img/4-6.jpg" referrerpolicy="no-referrer"></p><p><span>② 空闲分区链。为了实现对空闲分区的分配和链接，</span><strong><span>在每个分区的起始部分</span></strong><span>设置一些</span><strong><span>用于控制分区分配的信息</span></strong><span>，以及</span><strong><span>用于链接各分区所用的前向指针</span></strong><span>，在</span><strong><span>分区尾部</span></strong><span>则设置一</span><strong><span>后向指针</span></strong><span>。通过前、后向链接指针，可将所有的空闲分区链接成一个</span><strong><span>双向链</span></strong><span>。</span></p><p><span>当分区被分配出去后，状态位由0改为1，此时前后指针已无意义。</span></p><p><img src="img/4-7.jpg" referrerpolicy="no-referrer" alt=" 图4-7 空闲链结构 "></p></li><li><p><strong><span>动态分区分配算法</span></strong>
<span>为把一个新作业装入内存，须按照一定的分配算法，从空闲分区表或空闲分区链中选出一分区分配给该作业。</span></p><p><span>（1）</span><strong><span>顺序式搜索算法（4种） </span></strong></p><p><span>①首次适应算法(FF)：FF从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。</span></p><p><span>②循环首次适应算法(NF)：NF从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区</span></p><p><span>③最佳适应算法(BF)：BF总是把能满足要求、又是最小的空闲分区分配给作业。该算法要求将所有的空闲分区按其容量以</span><strong><span>从小到大</span></strong><span>的顺序形成一空闲分区链</span></p><p><span>④最坏适应算法(WF)：WF总是挑选一个最大的空闲区，从中分割一部分存储空间给作业使用，以至于存储器中缺乏大的空闲分区</span></p><p>&nbsp;</p><p><span>（2）</span><strong><span>索引式搜索算法（3种）</span></strong></p><p><span>①快速适应算法(quick fit)：该算法又称为分类搜索法，</span><strong><span>是将空闲分区根据其容量大小进行分类</span></strong><span>，对于每一类</span><strong><span>具有相同容量</span></strong><span>的所有空闲分区，</span><strong><span>单独设立一个空闲分区链表</span></strong><span>。同时，在内存中设立一张</span><strong><span>管理索引表</span></strong><span>，其中的</span><strong><span>每一个索引表项对应了一种空闲分区类型</span></strong><span>，并记录了该类型</span><strong><span>空闲分区链表头指针</span></strong><span>。</span></p><p><span>优点：</span><strong><span>不会对分区进行分割</span></strong><span>，能保留大的分区，</span><strong><span>也不会产生内存碎片</span></strong><span>，查找效率高</span></p><p><span>缺点：</span><strong><span>分区归还内存时算法复杂</span></strong><span>，系统开销较大。此外，该分配空闲分区时是以进程为单位的，每一个分区只属于一个进程，因此在</span><strong><span>为进程分配的一个分区中存在一定的浪费。</span></strong></p><p><span>②伙伴系统(buddy system)：该算法规定，无论已分配分区或空闲分区，其</span><strong><span>大小均为2的k次幂</span></strong><span>(k为整数，l≤k≤m)。通常</span><strong><span>2^m是整个可分配内存的大小</span></strong><span>(也就是最大分区的大小)。</span></p><p><span>假设系统的可利用空间容量为2^m 个字，则系统开始运行时，整个内存区是一个大小为2^m的空闲分区。在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区，将这些空闲分区按分区的大小进行分类。</span></p><p><strong><span>对于具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了k个空闲分区链表。</span></strong></p><p><span>在伙伴系统中，对于一个大小为2^k，地址为x的内存块，其伙伴块的地址则用buddyk(x)表示，其通式为：</span></p><p><img src="img/4-14.png" referrerpolicy="no-referrer" alt=" "></p><p><span>公式推导：设一个内存块地址为x，大小为2^(k+1)，我们知道伙伴块是由一个内存块划分为两个大小相同的内存块而来，所以将该内存块划分为两个内存块，一个内存块1地址为x1, x1=x，其伙伴块就是内存块2地址为x2, x2=x+2^k。又因为在伙伴系统中，</span><strong><span>地址较小的伙伴块</span></strong><span>，其</span><strong><span>地址数值等于其大小</span></strong><span>，或者地址数值为0，即x=0，或x=2^k，2^k为其大小，因此其</span><strong><span>地址数值模其大小</span></strong><span>一定为0。（ 在本例中其大小为2^(k+1)）</span></p><p><span>对内存块1来说，它就是</span><strong><span>地址较小</span></strong><span>的那一块，因此 x1 MOD 2^(k+1) = 0，其伙伴块地址就是x1 + 2^k = x + 2^k，即伙伴块2的地址；</span></p><p><span>对内存块2来说，x2 MOD 2^(k+1) = (x+2^k) MOD 2^(k+1) = 2^k，其伙伴块地址就是x2 - 2^k = x，即伙伴块1的地址。</span></p><p><span>由此，得证。</span></p><p><span>③</span></p></li><li><p><strong><span>分区分配操作</span></strong></p><p><span>分配内存：</span></p><p><span>　系统应利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。设请求的分区大小为u.size，表中每个空闲分区的大小可表示为m.size。</span></p><p><strong><span>⭐分配过程：</span></strong></p><p><span>找到一个分区后，若m.size-u.size &lt;= size，则说明剩余部分太小，不再分割，将整个分区分配给请求者，其中</span><strong><span>size为事先规定地不再分割地剩余分区的大小。</span></strong></p><p><span>否则，将该分区划出一块u.size的空间分配出去，剩下部分仍然留在空闲分区链中，然后将分配去的首址返回给调用者。</span></p><p><img src="img/4-8.jpg" referrerpolicy="no-referrer"></p><p><span>回收内存：</span></p><p><span>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点，此时可能出现以下四种情况之一： </span></p><p><span>(1) </span><strong><span>回收区与插入点的前一个空闲分区F1相邻接</span></strong><span>，见图(a)。此时应将回收区</span><strong><span>与插入点的前一分区合并</span></strong><span>，不必为回收分区分配新表项，而只需修改其前一分区F1的大小。</span>
<span>(2) </span><strong><span>回收分区与插入点的后一空闲分区F2相邻接</span></strong><span>，见图(b)。此时将两分区合并，</span><strong><span>形成新的空闲分区</span></strong><span>，但用</span><strong><span>回收区的首址</span></strong><span>作为新空闲区的首址，大小为两者之和。</span></p><p><span>(3) </span><strong><span>回收区同时与插入点的前、后两个分区邻接</span></strong><span>，见图(c)。此时将三个分区合并，</span><strong><span>使用F1的表项和F1的首址</span></strong><span>，</span><strong><span>取消F2的表项</span></strong><span>，大小为三者之和。</span></p><p><img src="img/4-9.jpg" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><span>(4) 回收区既不与F1邻接，又不与F2邻接。这时应为回收区单独建立一个新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。</span></p><p><img src="img/4-10.jpg" referrerpolicy="no-referrer"></p></li></ol><h4 id='434-动态可重定位分区分配'><span>4.3.4 动态可重定位分区分配</span></h4><p><span>1.</span><strong><span>紧凑</span></strong></p><p><strong><span>连续分配方式</span></strong><span>的一个重要</span><strong><span>特点</span></strong><span>是，</span><strong><span>一个系统或用户程序必须被装入一片连续的内存空间中</span></strong><span>。当一台计算机运行了一段时间后，它的内存空间将会被分割成许多小的分区，而缺乏大的空闲空间。即使这些分散的许多小分区的容量总和大于要装入的程序，但由于这些分区不相邻接，也无法把该程序装入内存</span></p><p><span>紧凑的概念：通过移动内存中作业的位置，</span><strong><span>把原来多个分散的小分区拼接成一个大分区的方法</span></strong><span>，称为紧凑。</span></p><p><span>紧凑带来的问题：经过紧凑后的用户程序在内存中的位置发生了变化，如果不对程序和数据的地址进行变换，程序无法执行。因此，每次紧凑后，都必须对移动了的程序进行重定位，而系统在运行过程中经常会进行紧凑，这将大大影响系统的效率。</span></p><p><img src="img/4-11.jpg" referrerpolicy="no-referrer"></p><p><span>2.</span><strong><span>动态重定位</span></strong></p><p><span>动态运行时装入的方式中，作业装入内存后的所有地址仍然都是相对(逻辑)地址。</span></p><p><span>而将相对地址转换为绝对(物理)地址的工作被推迟到程序指令要真正执行时进行。</span></p><p><span>为使地址的转换不会影响到指令的执行速度，必须有硬件地址变换机构的支持，即须在系统中增设一个</span><strong><span>重定位寄存器</span></strong><span>，</span><strong><span>用它来存放程序(数据)在内存中的起始地址</span></strong><span>。程序在执行时，</span><strong><span>真正访问的内存地址</span></strong><span>是</span><strong><span>相对地址</span></strong><span>与</span><strong><span>重定位寄存器中的地址</span></strong><span>相加而形成的。</span></p><p><span>动态重定位的概念：地址变换过程 是在程序执行期间，随着对每条指令或数据的访问自动进行的。</span></p><p><span>动态重定位的原理：当系统进行紧凑后，使若干程序从内存某处移动到另一处，不需要对程序进行修改，</span><strong><span>只要用该程序在内存的新起始地址去置换原来的起始地址即可。</span></strong></p><p><img src="img/4-12.jpg" referrerpolicy="no-referrer"></p><p><span>3.</span><strong><span>动态重定位分区分配算法</span></strong></p><p><span>动态重定位分区分配算法与动态分区分配算法基本上相同，</span><strong><span>差别仅在于增加了紧凑的功能</span></strong><span>。</span></p><p><span>通常，当该算法不能找到一个足够大的空闲分区以满足用户需求时，如果所有的小的空闲分区的容量总和大于用户的要求，这时便须对内存进行“紧凑”，将经“紧凑”后所得到的大空闲分区分配给用户。如果所有的小的空闲分区的容量总和仍小于用户的要求，则返回分配失败信息。</span></p><p><img src="img/4-13.jpg" referrerpolicy="no-referrer"></p><h3 id='44-对换'><span>4.4 对换</span></h3><h4 id='441-多道程序环境下的对换技术'><span>4.4.1 多道程序环境下的对换技术</span></h4><ol start='' ><li><p><span>对换的引入</span></p><p><span>在多道程序环境下，一方面，在内存中的</span><strong><span>某些进程</span></strong><span>由于某事件尚未发生而</span><strong><span>被阻塞</span></strong><span>运行，但它却</span><strong><span>占用了大量的内存空间</span></strong><span>，甚至有时可能出现在内存中所有进程都被阻塞，而无可运行之进程，迫使CPU停止下来等待的情况；另一方面，却又</span><strong><span>有着许多作业</span></strong><span>，</span><strong><span>因内存空间不足</span></strong><span>，一直驻留在外存上，而</span><strong><span>不能进入内存运行</span></strong><span>。</span></p><p><span>显然这对系统资源是一种严重的浪费，且使系统吞吐量下降。 为解决这一问题，系统中增设了对换设施。</span></p><p><strong><span>对换的概念：</span></strong><span>对换是指把内存中</span><strong><span>暂时不能运行的进程或暂时不用的程序和数据</span></strong><span>换出到外存上，以便腾出足够的内存空间，再把</span><strong><span>已具备运行条件的进程或进程所需要的程序和数据</span></strong><span>换入内存。</span></p><p><span>引入对换的好处：改善了内存利用率，提高了处理机的利用率和系统的吞吐量。</span></p></li><li><p><span>对换的类型</span></p><p><span>在每次对换时，都是将一定数量的程序或数据换入或换出内存。根据</span><strong><span>每次对换时所对换的数量</span></strong><span>，可将对换分为如下两类：</span>
<span> 　（1） 整体对换；以整个进程为单位进行对换，故称为进程对换或整体对换，在此只介绍整体对换。</span>
<span> 　（2）页面(分段)对换：以进程的一个页面或分段为单位进行对换，是实现请求分页和请求分段式存储管理的基础，目的式</span><strong><span>为了支持虚拟存储系统</span></strong><span>。</span></p><p>&nbsp;</p><p><span>为了实现进程对换，系统必须能实现：对</span><strong><span>对换空间的管理、进程的换出和进程的换入</span></strong><span>。</span></p></li></ol><h4 id='442-对换空间的管理'><span>4.4.2 对换空间的管理</span></h4><ol start='' ><li><p><span>对换空间管理的主要目标</span></p><p><span>在具有对换功能的OS中，通常把磁盘空间分为文件区和对换区两部分。</span></p><p><span>（1）对</span><strong><span>文件区</span></strong><span>管理的主要目标：提高文件存储空间的利用率，然后才是提高对文件的访问速度。对文件区空间采用</span><strong><span>离散分配方式</span></strong></p><p><span>（2）对</span><strong><span>对换空间</span></strong><span>管理的主要目标：提高进程换入和换出的速度，然后才是提高文件存储空间的利用率。对对换区空间采用</span><strong><span>连续分配方式</span></strong></p></li><li><p><span>对换区空闲盘块管理中的数据结构</span></p><p><span>数据结构用于</span><strong><span>记录外存对换区中的空闲盘块的使用情况</span></strong><span>。其数据结构包括空闲分区表或空闲分区链。</span></p><p><span>在空闲分区表的每个表目包含：</span><strong><span>对换区的首址及其大小</span></strong><span>，分别用盘块号和盘块数表示</span></p></li><li><p><span>对换空间的分配与回收</span></p><p><span>由于对换分区的分配采用的是连续分配方式，因而对换空间的分配与回收</span><strong><span>与动态分区方式时的内存分配与回收方法类似</span></strong><span>。其分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法等。具体的分配操作也与图4-8中内存的分配过程相同。</span></p></li></ol><h4 id='443-进程的换出与换入'><span>4.4.3 进程的换出与换入</span></h4><ol start='' ><li><p><span>进程的换出</span></p><p><span>对换进程在实现进程换出时，是将内存中的某些进程调出至对换区。换出过程可分为以下两步：</span>
<span> 　(1) 选择被换出的进程：首先选择处于阻塞状态或睡眠状态的进程，应优先选择优先级低的进程。如过没有，则选择优先级最低的就绪进程。</span>
<span> 　(2) 进程换出过程：先</span><strong><span>申请对换空间</span></strong><span>，若成功则</span><strong><span>启动磁盘</span></strong><span>，将该进程的程序和数据</span><strong><span>传送到磁盘的对换区</span></strong><span>。若传送过程没有错误，则</span><strong><span>回收</span></strong><span>该进程的</span><strong><span>内存空间</span></strong><span>，</span></p><p><span>·</span><span>		</span><span>并</span><strong><span>修改</span></strong><span>该进程的PCB和内存分配表等</span><strong><span>数据结构</span></strong><span>。如果内存中还</span><strong><span>有可换出的进程</span></strong><span>，则继续进行换出，</span><strong><span>直到内存中无阻塞进程</span></strong><span>为止。</span></p></li><li><p><span>进程的换入</span></p><p><span>对换进程将定时执行换入操作，它首先</span><strong><span>查看PCB集合</span></strong><span>中所有进程的状态，从中</span><strong><span>找出“就绪”状态但已换出的进程</span></strong><span>。当有许多这样的进程时，它将选择其中</span><strong><span>已换出到磁盘上时间最久</span></strong><span>(必须大于规定时间，如2 s)的进程作为换入进程，为它</span><strong><span>申请内存</span></strong><span>。如果申请成功，可直接将进程</span><strong><span>从外存调入内存</span></strong><span>；如果</span><strong><span>失败</span></strong><span>，则需先将内存中的某些进程</span><strong><span>换出</span></strong><span>，腾出足够的内存空间后，</span><strong><span>再</span></strong><span>将进程</span><strong><span>调入</span></strong><span>。</span></p></li></ol><h3 id='45分页存储管理方式⭐'><span>4.5分页存储管理方式⭐</span></h3><p><span>离散存储方式的引出：如果允许将一个进程直接分散装入到许多不相邻接的分区中，便可以充分利用内存空间，而不用再进行紧凑。</span></p><p><span>内存的</span><strong><span>3种离散分配管理方式</span></strong><span>：</span></p><p><span>(1) </span><strong><span>分页存储管理方式</span></strong><span>：将用户程序的地址空间分为若干个固定大小的区域，称为页。同时将内存空间分为若干各物理块，页和块的大小系统。这样可将用户程序的任一页放入任一物理块，实现了离散分配</span>
<span>(2) </span><strong><span>分段存储管理方式</span></strong><span>：把用户程序的地址空间分为若干该格大小不同的段，每段可定义一组相对完整的信息。分配时以段位单位，这些段在内存中可不相邻接。</span></p><p><span>(3) </span><strong><span>段页式存储管理方式</span></strong><span> ：结合分页和分段两种存储管理方式的产物。</span></p><h4 id='451-分页存储管理的基本方法'><span>4.5.1 分页存储管理的基本方法</span></h4><ol start='' ><li><p><strong><span>页面和物理块</span></strong></p><p><span>(1) 页面：</span></p><p><span>分页存储管理将紧凑的逻辑地址空间分为若干各页，每页加以编号。同时把内存的物理地址空间分成若干各块，每块加以编号。在为进程分配内存时，以块为单位，将进程的若干页分别装入到多个可以不相邻接的物理块中。</span></p><p><span> (2) 页面大小：</span></p><p><span>页面大小过小可以减少内存碎片，提高内存利用率，但会造成每个进程占用较多的页面，导致进程页表过长占用大量内粗；页面大小过大可以减少页表长度，提高换进换出的效率，但会使业内碎片增大。</span></p><p><span>因此，页面大小应适中，且为2的幂，一般为1KB~8KB</span></p></li><li><p><strong><span>地址结构</span></strong></p><p><span>分页地址中的地址结构如下：</span><strong><span>页号+页内地址</span></strong></p><p><img src="img/4-15.png" referrerpolicy="no-referrer"></p><p><span>对某特定机器，其地址结构是一定的。若给定一个逻辑地址空间中的地址为A，页面的大小为L，则页号P和页内地址d可按下式求得</span></p><p>&nbsp;</p><p><img src="img/4-16.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><span>例如，某系统页面大小为1KB，设A = 2170 B ，则P = INT(2170 / 1024) = 2, d = 2170 MOD 1024 = 122 </span></p></li><li><p><span>页表</span></p><p><span>在分页系统中，允许将进程的各个页离散地存储在内存的任一物理块中，</span><strong><span>为保证进程仍然能够正确地运行</span></strong><span>，即</span><strong><span>能在内存中找到每个页面所对应的物理块</span></strong><span>，系统又为</span><strong><span>每个进程建立了一张页面映像表，简称页表</span></strong></p><p><img src="img/4-17.jpg" referrerpolicy="no-referrer"></p></li></ol><p><span>页表的作用：</span><strong><span>实现从页号到物理块号的地址映射</span></strong></p><h4 id='452-地址变换机构逻辑地址-物理地址）'><span>4.5.2 地址变换机构（逻辑地址-&gt;物理地址）</span></h4><p><span>地址变换机构的任务实际上是</span><strong><span>将逻辑地址的页号转换为内存中的物理块号</span></strong><span>，又因为页表的作用就是实现页号到物理块号的变换，因此，地址变换任务是</span><strong><span>借助于页表实现的</span></strong><span>。</span></p><ol start='' ><li><p><span>基本的地址变换机构</span>
<span>进程在运行期间，</span><strong><span>需要对程序和数据的地址进行变换</span></strong><span>，即</span><strong><span>将用户地址空间中的逻辑地址变换为内存空间中的物理地址</span></strong><span>，由于它执行的频率非常高，每条指令的地址都需要进行变换，因此需要采用硬件来实现，一般是寄存器。</span></p><p><span>因寄存器成本较高，所以系统中一般只设置一个页表寄存器PTR，用于存放页表在内存的始址和页表的长度。程序未执行时，页表存放在本进程的PCB中，当被调度时，才将页表装入寄存器中。</span></p><p>&nbsp;</p><p><span>进程访问数据的过程：</span></p><p><span>先将页号P与页表长度M比较。</span>
<span>①若越界，即 P≥M，则表示地址越界并中断。</span>
<span>② 若未越界，则将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，从中得到该页的物理块号在内存的地址，装入物理地址寄存器。</span>
<span>将有效地址中的页内地址送入物理地址寄存器的块内地址字段中，即可得到要访问的内存物理地址。</span></p><hr /><p><img src="img/4-18.jpg" referrerpolicy="no-referrer"></p></li><li><p><span>具有快表的地址变换机构</span></p><p><span>由于页表是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。第一次是访问内存中的页表，从中找到指定页的物理块号，再将块号与页内偏移量W拼接，以形成物理地址。第二次访问内存时，才是从第一次所得地址中获得所需数据(或向此地址中写入数据)。因此，采用这种方式将使计算机的处理速度降低近1/2。可见，以此高昂代价来换取存储器空间利用率的提高，是得不偿失的。</span></p><p>&nbsp;</p><p><span>引入快表的目的：为了提高地址变换速度</span></p><p><span>快表的概念：在地址变换机构中增设一个具有</span><strong><span>并行查询能力</span></strong><span>的</span><strong><span>特殊高速缓冲寄存器</span></strong><span>，又称为联想寄存器，或快表。</span></p><p><strong><span>引入快表后的地址变换过程</span></strong><span>：</span></p><p><span>①在快表中查找页号P，如果有，则可以直接得到物理块号的位置，并送人物理地址寄存器。</span></p><p><span>②如果快表中没有找到页号P，则访问内存中的页表，计算物理块号的地址，再送入物理地址寄存器。同时，将该页表项存入快表。</span></p><p><span>③若快表已满，则找到一个老的且不再需要的页表项换出，再存入新的页表项。</span></p><p><img src="img/4-19.jpg" referrerpolicy="no-referrer"></p><p>&nbsp;</p></li></ol><h4 id='453-访问内存的有效时间-eat'><strong><span>4.5.3 访问内存的有效时间</span></strong><span> EAT</span></h4><p><span>从进程</span><strong><span>发出</span></strong><span>指定逻辑地址的</span><strong><span>访问请求</span></strong><span>，</span><strong><span>经过地址变换</span></strong><span>，到在内存中</span><strong><span>找到对应的实际物理地址单元并取出数据</span></strong><span>，所需要花费的总时间，称为内存的有效访问时间</span></p><p><span>假设</span><strong><span>访问一次内存的时间为t</span></strong><span>，在</span><strong><span>基本分页存储管理方式</span></strong><span>中，有效访问时间分为第一次访问内存时间(即查找页表对应的页表项所耗费的时间t)与第二次访问内存时间(即将页表项中的物理块号与页内地址拼接成实际物理地址所耗费的时间t)之和：</span>
<span> 　　　　　　　　</span><strong><span>EAT = t + t = 2t</span></strong></p><p><span>在</span><strong><span>引入快表的分页存储管理方式</span></strong><span>中，通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成实际物理地址，减少了一次内存访问，缩短了进程访问内存的有效时间。但是，由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，所以在快表中查找到所需表项存在着命中率的问题。所谓命中率，是指使用快表并在其中成功查找到所需页面的表项的比率。这样，在引入快表的分页存储管理方式中，有效访问时间的计算公式即为： </span>
<span>       </span><strong><span>EAT= а×λ+(t+λ)(1-а)+t= 2t + λ - t × а</span></strong>
<span> 上式中，</span><strong><span>λ表示查找快表所需要的时间，а表示命中率，t表示访问一次内存所需要的时间</span></strong><span>。</span></p><p><span>可见，引入快表后的内存有效访问时间分为查找到逻辑页对应的页表项的平均时间а × λ + (t + λ)(1 - а)，以及对应实际物理地址的内存访问时间t。假设对快表的访问时间λ为20 ns(纳秒)，对内存的访问时间t为100 ns，则下表中列出了不同的命中率а与有效访问时间的关系：</span></p><p><img src="img/4-20.jpg" referrerpolicy="no-referrer"></p><h4 id='454-两级和多级页表'><span>4.5.4 两级和多级页表</span></h4><ol start='' ><li><p><span>两级页表</span></p><p><span>针对</span><strong><span>难于找到大的连续的内存空间来存放页表</span></strong><span>的问题，可利用将页表进行分页的方法，使每个页面的大小与内存物理块的大小相同，并为它们进行编号。</span></p><p><span>然后离散地将各个页面分别存放在不同的物理块中。同样，也要为离散分配的页表</span><strong><span>再建立一张页表</span></strong><span>，称为</span><strong><span>外层页表</span></strong><span>，在每个页表项中记录页面的物理块号。 </span></p><p><span>外层页内地址存放的时页表PT所在的物理块号，页内地址存放的时PT对应的物理块号。</span></p><p><img src="img/4-21.jpg" referrerpolicy="no-referrer"></p><p><span>为了方便实现地址变换，在地址变换机构中，同样需要增设一个</span><strong><span>外层页表寄存器</span></strong><span>，用于</span><strong><span>存放外层页表的始址</span></strong><span>，并</span><strong><span>利用逻辑地址中的外层页号作为外层页表的索引，从中找到指定页表分页的始址，再利用P2作为指定页表分页的索引，找到指定的页表项，其中即含有该页在内存的物理块号，用该块号P和页内地址d即可构成访问的内存物理地址。</span></strong></p><p><img src="img/4-22.jpg" referrerpolicy="no-referrer"></p></li><li><p><span>多级页表</span></p><p><span>对于32位的机器，采用两级页表结构是合适的，但对于64位的机器，采用两级页表是否仍然合适，须做以下简单分析。如果页面大小仍采用4 KB即4096B，那么还剩下52位，假定仍按物理块的大小(4096位)来划分页表，则将余下的42位用于外层页号。此时在外层页表中可能有4096 G个页表项，要占用16 384 GB的连续内存空间，显然是不合适的。</span></p></li></ol><p>&nbsp;</p><h4 id='455-反置页表'><span>4.5.5 反置页表</span></h4><p>&nbsp;</p><h3 id='46-分段存储管理方式⭐'><span>4.6 分段存储管理方式⭐</span></h3><p><span>当OS由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。 </span></p><h4 id='461-分段存储管理方式的引入'><span>4.6.1 分段存储管理方式的引入</span></h4><p><strong><span>为什么要引入分段式存储管理方式？</span></strong></p><ol start='' ><li><strong><span>方便编程</span></strong>
<span>通常，程序员们编写的程序访问的逻辑地址是由段号和段内偏移量决定的，这不仅可以方便程序员编程，也可使程序非常直观，更具可读性。</span></li><li><strong><span>信息共享</span></strong>
<span>在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。段可以是信息的逻辑单位，因此为共享过程建立一个独立的段就极大简化了共享的实现。</span></li><li><strong><span>信息保护</span></strong>
<span>信息保护同样是以信息的逻辑单位为基础的，因此分段管理方式能更有效和方便的实现对信息的保护功能。</span></li><li><strong><span>动态增长</span></strong>
<span>在实际应用中，往往存在着一些段，由于数据量的不断增加，而使数据段动态增长，相应地它所需要的存储空间也会动态增加。对此，很难采取预先多分配的方法进行解决，而分段存储管理方式能较好的解决这一问题。</span></li><li><strong><span>动态链接</span></strong>
<span>运行时动态链接，即在程序运行过程中，当需要调用某个目标程序时，才将该段调入内存并进行链接。 可见，动态链接要求的是以目标程序（即段）作为链接的基本单位，因此，分段存储管理方式非常适合动态链接。</span></li></ol><h4 id='462-分段系统的基本原理'><span>4.6.2 分段系统的基本原理 </span></h4><ol start='' ><li><p><span>分段</span></p><p><span>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。</span></p><p><span>可以用一个段号代替段名，每个段都</span><strong><span>从0开始编址</span></strong><span>，并采用一段连续的地址。</span></p><p><span>段的长度又相应的逻辑信息组的长度决定，因此</span><strong><span>各段长度不相等</span></strong><span>。</span></p><p><strong><span>逻辑地址由段号和段内地址组成</span></strong><span> ：</span></p><p><img src="img/4-23.jpg" referrerpolicy="no-referrer"></p></li><li><p><span>段表</span></p><p><span>在前面所介绍的动态分区分配方式中，系统为整个进程分配一个连续的内存空间。而在分段式存储管理系统中，则是为每个分段分配一个连续的分区。进程中的各个段，可以离散地装入内存中不同的分区中。为保证程序能正常运行，就必须能从物理内存中找出每个逻辑段所对应的位置。</span></p><p><img src="img/4-24.jpg" referrerpolicy="no-referrer"></p><p><span>段表的概念：系统为每个进程建立的一张</span><strong><span>段映射表</span></strong><span>，每个表项记录了该段在</span><strong><span>内存的起始地址和段长</span></strong><span>，用于</span><strong><span>实现从逻辑地址段到物理内存区的映射</span></strong><span>。</span></p></li><li><p><span>地址变换机构</span></p><p><span>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址和段表长度TL。</span></p><p><span>在进行地址变换时，系统将逻辑地址中的段号与段表长度TL进行比较。若S&gt;TL，表示段号太大，是访问越界，于是产生越界中断信号。</span></p><p><span>若未越界，则</span><strong><span>根据段表的始址和该段的段号</span></strong><span>，计算出该段对应段表项的位置，从中读出该段在内存的起始地址。然后，再检查段内地址d是否超过该段的段长SL。若超过，即d&gt;SL，同样发出越界中断信号。若未越界，则将该段的基址d与段内地址相加，即可得到要访问的内存物理地址。图4-20示出了分段系统的地址变换过程。</span></p><p><img src="img/4-25.jpg" referrerpolicy="no-referrer"></p></li></ol><p><strong><span>⭐分页和分段有什么区别?</span></strong></p><ol start='' ><li><p><strong><span>页是信息的物理单位</span></strong><span>。</span></p><p><span>采用分页存储管理方式是为了实现离散分配方式，提高内存利用率，仅仅是</span><strong><span>系统管理上的需要</span></strong><span>，对用户是不可见的。</span></p><p><span>分段存储管理方式中的</span><strong><span>段则是信息的逻辑单位</span></strong><span>，通常是一组意义完整的信息，分段的目的是</span><strong><span>更好的满足用户的需要</span></strong><span>。</span></p></li><li><p><strong><span>页的大小固定且由系统决定</span></strong><span>。</span></p><p><span>在采用分页存储管理方式的系统中，用户程序的逻辑地址由硬件决定，因而在系统中页面大小是固定的。而段的长度取决于用户编写的程序。</span></p></li><li><p><strong><span>分页的用户程序地址空间是一维的</span></strong><span>。</span></p><p><span>在分页系统中，用户程序的地址是单一的线性地址可见。而分段式用户的行为，所以在分段系统站用户程序的地址可见是二维的。</span></p></li></ol><h4 id='463-信息共享'><span>4.6.3 信息共享</span></h4><p><span>1.</span><strong><span>分页系统中对程序和数据的共享</span></strong></p><p><span> 　在分页系统中，虽然也能实现对程序和数据的共享，但远不如分段系统来得方便。我们通过一个例子来说明这个问题。</span></p><p><img src="img/4-26.jpg" referrerpolicy="no-referrer"></p><p><span>2.</span><strong><span>分段系统中程序和数据的共享</span></strong></p><p><span>在分段系统中，由于是以段为基本单位的，不管该段有多大，我们都只需为该段设置一个段表项，因此使实现共享变得非常容易。我们仍以共享editor为例，此时只需在(每个)进程1和进程2的段表中，为文本编辑程序设置一个段表项，让段表项中的基址(80)指向editor程序在内存的起始地址。</span></p><p><img src="img/4-27.jpg" referrerpolicy="no-referrer"></p><h4 id='464-段页式存储管理方式'><span>4.6.4 段页式存储管理方式</span></h4><p><span>1.</span><strong><span>基本原理</span></strong></p><p><span>段页式系统的基本原理是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。图4-23(a)示出了一个作业地址空间的结构。该作业有三个段：主程序段、子程序段和数据段；页面大小为 4 KB。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成</span></p><p><img src="img/4-28.jpg" referrerpolicy="no-referrer"></p><p><span>在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中需要同时配置段表和页表。段表的内容与分段系统略有不同，它不再是内存始址和段长，而是页表始址和页表长度。</span></p><p><img src="img/4-29.jpg" referrerpolicy="no-referrer"></p><p><span>2.</span><strong><span>地址变换过程</span></strong></p><p><span>在段页式系统中，为了便于实现地址变换，须配置一个段表寄存器，其中存放段表始址和段长TL。进行地址变换时，首先利用段号S，将它与段长TL进行比较。若S &lt; TL，表示未越界，于是利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b，再利用块号b和页内地址来构成物理地址。图4-25示出了段页式系统中的地址变换机构。</span></p><p><img src="img/4-30.jpg" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h2 id='5虚拟存储器'><span>5.虚拟存储器</span></h2><h3 id='51-虚拟存储器概述'><span>5.1 虚拟存储器概述</span></h3><h4 id='511-常规存储器管理方式的特征和局部性原理'><span>5.1.1 常规存储器管理方式的特征和局部性原理</span></h4><p><span>1.常规存储器管理方式的特征：</span></p><p><span>（1）一次性：指作业必须一次性的全部装入内存后才能开始运行</span></p><p><span>（2）驻留性：指作业被装入内存后，整个作业都一直驻留在内存中，直至作业运行结束。</span></p><p><span>这些特性带来的问题：许多在程序运行中不用或暂时不用的程序或数据占据了大量内存空间，而一些需要运行的作业又无法装入运行，浪费了内存资源。                  </span></p><p>&nbsp;</p><p><span>2.</span><strong><span>局部性原理</span></strong><span>⭐</span></p><p><strong><span>程序在执行时呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分，相应的，它访问的存储空间也局限于某个区域。</span></strong></p><p><span>局限性又表现在两个方面</span></p><p><span>（1）</span><strong><span>时间局限性</span></strong><span>：如果程序中某条指令被执行，则不久后可能在此被执行。如果某数据被访问，则不久后可能再次被访问。（原因是程序中存在大量循环操作）</span></p><p><span>（2）</span><strong><span>空间局限性</span></strong><span>：如果程序访问了某个存储单元，则不久后其附近的存储单元也被访问，即程序在一段时间内访问的地址集中在一定范围之内。</span></p><h4 id='512-虚拟存储器的定义和特征-⭐'><span>5.1.2 虚拟存储器的定义和特征 ⭐</span></h4><p><span>1.</span><strong><span>虚拟存储器的定义</span></strong></p><p><span>虚拟存储器就是指具有请求调入功能和置换功能，能从逻辑上对内存容量扩充的一种存储器系统。</span></p><p><span>2.</span><strong><span>虚拟存储器的特征</span></strong></p><p><span>（1）多次性：指一个作业的</span><strong><span>程序和数据允许被分成多次调入内存运行</span></strong><span>，即只需将当前要运行时的部分调入即可开始运行，以后需要未调入的部分才再调入。</span></p><p><span>（2）对换性：指一个作业的程序和数据允许在作业运行时换进换出，即进程运行期间，允许将暂不使用的代码和数据从内存换出，以后需要时再换进内存。</span></p><p><span>（3）虚拟性：指能够从逻辑上扩充内存容量，使用户看到的内存容量大于实际内存容量。这样就可以在小内存中运行大作业，有效改善了内存利用率。</span></p><p><strong><span>虚拟性</span></strong><span>是</span><strong><span>以多次性和对换性为基础</span></strong><span>的，而</span><strong><span>多次性和对换性</span></strong><span>又是建立在</span><strong><span>离散分配</span></strong><span>的基础上的，是最本质的特征。</span></p><h4 id='513-虚拟存储器的实现方法'><span>5.1.3 虚拟存储器的实现方法 </span></h4><p><span>1.</span><strong><span>分页请求系统</span></strong><span>：</span></p><p><span>硬件支持：请求分页的页表机制、缺页中断机构、地址变换机构</span></p><p><span>软件支持：实现请求分页的软件和实现页面置换的软件</span></p><p><strong><span>2.分段请求系统：</span></strong></p><p><span>硬件支持：请求分段的段表机制、却段中断机构、地址变换机构</span></p><p><span>软件支持：实现请求调段的软件和实现段置换的软件</span></p><h3 id='52-请求分页存储管理方式-⭐'><span>5.2 请求分页存储管理方式 ⭐</span></h3><h4 id='521-请求分页中的硬件支持'><span>5.2.1 请求分页中的硬件支持</span></h4><p><span>1.请求页表机制</span></p><p><span>在请求 分页系统中的每个页表项如下所示：</span></p><p><img src="img/5-1.png" referrerpolicy="no-referrer"></p><p><span>现对其中各字段说明如下：</span></p><p><span> (1) </span><strong><span>状态位 P</span></strong><span>：用于指示该页</span><strong><span>是否已调入内存</span></strong></p><p><span> (2) </span><strong><span>访问字段 A</span></strong><span>：用于记录本页在一段时间内</span><strong><span>被访问的次数</span></strong><span>，供</span><strong><span>选择换出页面时参考</span></strong></p><p><span> (3) </span><strong><span>修改位 M</span></strong><span>：表示该页在</span><strong><span>调入内存后是否被修改过</span></strong><span>。若</span><strong><span>未被修改</span></strong><span>，在置换该页时就</span><strong><span>不需再将该页写回到外存</span></strong><span>上；若</span><strong><span>已被修改</span></strong><span>，则必须将该页</span><strong><span>重写到外存</span></strong><span>上。简言之，</span><strong><span>M 位供置换页面时参考</span></strong></p><p><span> (4) 外存地址：用于指出该页在外存上的地址，通常是</span><strong><span>物理块号</span></strong><span>，供</span><strong><span>调入该页时参考</span></strong></p><p><span>2.缺页中断机构</span></p><p><span>在请求分页系统中，每当所要访问的页面不在内存时，便产生一</span><strong><span>缺页中断</span></strong><span>，请求 OS 将 所缺之页调入内存。</span></p><p><span>缺页中断与一般的中断相比，有着明显的区别：</span></p><p><span> (1) </span><strong><span>在指令执行期间产生和处理中断信号</span></strong><span>。通常，CPU 都是在一条指令执行完后，才检查是否有中断请求到达。缺页中断是在指令执行期间，</span><strong><span>发现所要访问的指令或数据不在内存时</span></strong><span>所产生和处理的。</span></p><p><span> (2) 一</span><strong><span>条指令在执行期间，可能产生多次缺页中断</span></strong><span>。在图 4-24 中示出了一个例子。如 在执行一条指令 COPY A TO B 时，可能要产生 6 次缺页中断，其中指令本身跨了两个页面， A 和 B 又分别各是一个数据块，也都跨了两个页面。基于这些特征，系统中的硬件机构应</span><strong><span>能保存多次中断时的状态</span></strong><span>，并</span><strong><span>保证最后能返回到中断前产生缺页中断的指令处继续执行</span></strong><span>。</span></p><p><img src="img/5-2.png" style="zoom:50%;" /></p><p><span>3.地址变换机构</span></p><p><span>请求分页系统中的地址变换机构，是</span><strong><span>在分页系统地址变换机构的基础上</span></strong><span>，再增加实现虚拟存储器的某些功能，如</span><strong><span>产生和处理缺页中断</span></strong><span>，以及从内存中换出一页的功能等等。</span></p><p><span>在进行地址变换时，</span><strong><span>首先去检索快表</span></strong><span>，试图从中</span><strong><span>找出所要访问的页</span></strong><span>。</span></p><p><span>（1）若找到，便修改页表项中的访问位。然后利用页表项中给出的物理块号和页内地址形成物理地址</span></p><p><span>（2）未找到，应到内存中去查找页表，再从找到的页表项中的状态位 P，来了解该页是否已调入内存。</span></p><p><span>若该页</span><strong><span>已调入内存</span></strong><span>，这时应将此页的页表项</span><strong><span>写入快表</span></strong><span>。当</span><strong><span>快表已满</span></strong><span>时，应</span><strong><span>先调出</span></strong><span>按某种算法所确定的</span><strong><span>页的页表项</span></strong><span>，然后</span><strong><span>再写入该页的页表项</span></strong><span>；</span></p><p><span>若该页尚</span><strong><span>未调入内存</span></strong><span>，这时应</span><strong><span>产生缺页中断</span></strong><span>，请求 OS 从外存把该页调入内存。</span></p><p><img src="img/5-3.png" style="zoom: 80%;" /></p><p>&nbsp;</p><h4 id='522-请求分页中的内存分配'><span>5.2.2 请求分页中的内存分配</span></h4><p><span>在</span><strong><span>为进程分配内存</span></strong><span>时，将涉及到</span><strong><span>三个问题</span></strong><span>：第一，最小物理块数的确定；第二，物理 块的分配策略；第三，物理块的分配算法。</span></p><p><span>1.最小物理块数的确定</span></p><p><span>这里所说的最小物理块数，</span><strong><span>是指能保证进程正常运行所需的最小物理块数</span></strong><span>。</span></p><p><span>当系统为 进程分配的物理块数少于此值时，进程将无法运行。进程应获得的最少物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。</span></p><p><span>2.</span><strong><span>物理块的分配策略</span></strong></p><p><span>在请求分页系统中，可采取两种</span><strong><span>内存分配策略</span></strong><span>，即</span><strong><span>固定和可变分配</span></strong><span>策略。在</span><strong><span>进行置换</span></strong><span>时，也可采取两种策略，即</span><strong><span>全局置换和局部置换</span></strong><span>。</span></p><p><span>（1) </span><strong><span>固定分配局部置换</span></strong><span>：</span><strong><span>固定分配</span></strong><span>是指为每个进程</span><strong><span>分配一组固定数目的物理块</span></strong><span>，在进程</span><strong><span>运行期间不再改变</span></strong><span>。</span><strong><span>局部置换</span></strong><span>是指如果进程在运行中发现缺页，</span><strong><span>只能从分配给该进程的n个页面</span></strong><span>中选出一页换出，然后再调入一页，</span><strong><span>保证分配给进程的内存空间不变</span></strong><span>。</span></p><p><span>实现这种策略的困难在于：</span><strong><span>应为每个进程分配多少个物理块难以确定</span></strong><span>。若</span><strong><span>太少</span></strong><span>，会</span><strong><span>频繁地出现缺页中断</span></strong><span>，降低了系统的吞吐量；若</span><strong><span>太多</span></strong><span>， 又必然</span><strong><span>使内存中驻留的进程数目减少</span></strong><span>，进而可能造成 </span><strong><span>CPU 空闲或其它资源空闲</span></strong><span>的情况，而且在</span><strong><span>实现进程对换</span></strong><span>时，会</span><strong><span>花费更多的时间</span></strong><span>。 </span></p><p><span>（2) </span><strong><span>可变分配全局置换</span></strong><span>：可变分配是指先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。全局置换是指如果进程在运行期间发现缺页，则将系统所保留的空闲物理中的一块分配给该进程，或从所有进程的物理块中选择一块换出，然后将所缺页调入。</span></p><p><span>在采用这种策略时，当某进程发现缺页时，由系统从空闲物理块队列中取出一个物理块分配给该进程， 并将欲调入的(缺)页装入其中。这样，凡产生缺页(中断)的进程，都将获得新的物理块。</span><strong><span>仅当空闲物理块队列中的物理块用完时</span></strong><span>，OS 才能从内存中选择一页调出，该页可能是系统中任一进程的页，这样，自然又会使那个进程的物理块减少，进而使其缺页率增加。 </span></p><p><span>（3) </span><strong><span>可变分配局部置换</span></strong><span>：这同样是</span><strong><span>基于进程的类型或根据程序员的要求</span></strong><span>，为每个进程分配一定数目的物理块， 但当某进程发现缺页时，只允许从</span><strong><span>该进程在内存的页面</span></strong><span>中选出一页换出，这样就</span><strong><span>不会影响 其它进程的运行</span></strong><span>。</span><strong><span>如果</span></strong><span>进程在运行中频繁地发生缺页中断，则系统须再为该进程</span><strong><span>分配若干附加的物理块</span></strong><span>，</span><strong><span>直至</span></strong><span>该进程的</span><strong><span>缺页率减少到适当程度</span></strong><span>为止；反之，若一个进程在运行过程中的</span><strong><span>缺页率特别低</span></strong><span>，则此时可适当</span><strong><span>减少分配给该进程的物理块数</span></strong><span>，但不应引起其缺页率的明显增加。</span></p><p><span>3.物理块分配算法</span></p><p><span>在采用</span><strong><span>固定分配</span></strong><span>策略时，如何将系统中可供分配的所有物理块分配给各个进程，可采用下述几种算法。</span></p><p><span>（1) </span><strong><span>平均分配算法</span></strong><span>：</span><strong><span>这是将系统中所有可供分配的物理块平均分配给各个进程</span></strong><span>。</span></p><p><span>例如，当系统中有 100 个 物理块，有 5 个进程在运行时，每个进程可分得 20 个物理块。这种方式貌似公平，但实际 上是不公平的，因为它未考虑到各进程本身的大小。如有一个进程其大小为 200 页，只分 配给它 20 个块，这样，它必然会有很高的缺页率；而另一个进程只有 10 页，却有 10 个物 理块闲置未用。 </span></p><p><span>（2) </span><strong><span>按比例分配算法</span></strong><span>： </span><strong><span>这是根据进程的大小按比例分配物理块的算法</span></strong><span>。</span></p><p><span>如果系统中共有 n 个进程，每个进程 的页面数为 Si，则系统中各进程页面数的总和为：</span></p><p><img src="img/5-4.png" referrerpolicy="no-referrer"></p><p><span>又假定系统中可用的</span><strong><span>物理块总数为 m</span></strong><span>，则</span><strong><span>每个进程所能分到的物理块数为 bi</span></strong><span>，将有：</span></p><p><img src="img/5-5.png" referrerpolicy="no-referrer"></p><p><span>b 应该取整，</span><strong><span>它必须大于最小物理块数</span></strong><span>。 </span></p><p><span>（3) 考虑优先权的分配算法：</span><strong><span>在实际应用中，为了照顾到重要的、紧迫的作业能尽快地完成，应为它分配较多的内存空间。</span></strong></p><p><span>通常采取的方法是把内存中可供分配的所有物理块分成两部分：一部分按比例地分配给各进程；另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程。在有的系统中，如重要的实时控制系统，则可能是完全按优先权来为各进程分配其物 理块的。</span></p><h4 id='523-页面调入策略'><span>5.2.3 页面调入策略</span></h4><p><span>为使进程能够正常运行，必须时间先把将要执行的那部分程序和数据所在的页面调入内存。</span></p><p><span>1.</span><strong><span>何时调入页面？</span></strong><span> </span><strong><span>(调入页面的时机)</span></strong></p><p><span>为了确定系统将进程运行时所缺的页面调入内存的时机，可采取预调页策略或请求调页策略。 </span></p><p><span>（1）</span><strong><span>预调页策略</span></strong><span> </span></p><p><strong><span>如果进程的许多页是存放在外存的一个连续区域中</span></strong><span>，则</span><strong><span>一次调入若干个相邻的页</span></strong><span>，会比一次调入一页更高效些。但</span><strong><span>如果</span></strong><span>调入的一批页面中的</span><strong><span>大多数都未被访问</span></strong><span>，则又是低效的。 可采用一种</span><strong><span>以预测为基础的预调页策略</span></strong><span>，将那些</span><strong><span>预计在不久之后便会被访问的页面预先调入内存</span></strong><span>。</span></p><p><span>这种策略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。 </span></p><p><span>（2） </span><strong><span>请求调页策略</span></strong><span> </span></p><p><span>当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即请求 OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是</span><strong><span>一定会被访问</span></strong><span>的。</span><u><span>但这种策略</span><strong><span>每次仅调入一页</span></strong><span>，</span><strong><span>故系统开销较大，增加了磁盘 I/O 的启动 频率。</span></strong></u><span> </span></p><p><span>2.</span><strong><span>系统从何处调入这些页面？（确定从何处调入页面）</span></strong></p><p><span>在请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。发生缺页请求时，系统应从何处将缺页调入内存，可分外3种情况：</span></p><p><span> (1) </span><strong><span>系统拥有足够的对换区空间</span></strong><span>，这时可以</span><strong><span>全部从对换区调入所需页面</span></strong><span>，以提高调页速度。在进程运行前，便须将</span><strong><span>与该进程有关的文件</span></strong><span>从文件区</span><strong><span>拷贝到对换区</span></strong></p><p><span> (2) </span><strong><span>系统缺少足够的对换区空间</span></strong><span>，这时</span><strong><span>凡是不会被修改的文件</span></strong><span>都直接</span><strong><span>从文件区调入</span></strong><span>；而当</span><strong><span>换出这些页面时</span></strong><span>，由于它们</span><strong><span>未被修改而不必再将它们换出</span></strong><span>，以后再调入时，</span><strong><span>仍从文件区直接调入</span></strong><span>。但对于那些</span><strong><span>可能被修改的部分</span></strong><span>，在将它们</span><strong><span>换出时</span></strong><span>，</span><strong><span>必须调到对换区</span></strong><span>，以后需要时，再从对换区调入。 </span></p><p><span>(3) </span><strong><span>UNIX 方式</span></strong><span>。由于与进程有关的文件都放在文件区，故凡是</span><strong><span>未运行过的页面</span></strong><span>，</span><strong><span>都应从文件区调入</span></strong><span>。</span><strong><span>曾经运行过但又被换出的页面</span></strong><span>，由于是被放在对换区，因此在下次</span><strong><span>调入时，应从对换区调入</span></strong><span>。由于 UNIX 系统允许页面共享，因此，某进程所请求的页面有可能已被其它进程调入内存，此时也就无须再从对换区调入。</span></p><p><span>3.⭐</span><strong><span>如何进行调入？（页面调入过程）</span></strong></p><ul><li><span>①每当程序</span><strong><span>所要访问的页面未在内存</span></strong><span>时，便向 CPU </span><strong><span>发出一缺页中断</span></strong><span>，</span></li><li><span>②中断处理程序首先</span><strong><span>保留 CPU 环境</span></strong><span>，</span><strong><span>分析中断原因</span></strong><span>后</span><strong><span>转入缺页中断处理程序</span></strong><span>。</span></li><li><span>③</span><strong><span>缺页中断处理程序</span></strong><span>通过</span><strong><span>查找页表</span></strong><span>，</span><strong><span>得到</span></strong><span>该页在外存的</span><strong><span>物理块</span></strong></li><li><span>④如果此时</span><strong><span>内存能容纳新页</span></strong><span>，则将所缺之页</span><strong><span>调入内存</span></strong><span>，然后</span><strong><span>修改页表</span></strong></li><li><span>⑤如果</span><strong><span>内存已满</span></strong><span>，则须先按照某种置换算法从内存中</span><strong><span>选出一页准备换出</span></strong><span>。如果该页未被修改过，可不必将该页写回磁盘；但如果</span><strong><span>此页已被修改</span></strong><span>，则</span><u><span>必须将它</span><strong><span>写回磁盘</span></strong><span>，然后再把</span><strong><span>所缺的页</span></strong><span>调入内存，并修改页表中的相应表项，</span><strong><span>置其存在位为“1”</span></strong><span>，并将此页表项 写入快表中。</span></u></li><li><span>⑥在</span><strong><span>缺页调入内存后</span></strong><span>，利用修改后的页表，去</span><strong><span>形成</span></strong><span>所要访问数据的</span><strong><span>物理地址</span></strong><span>，再去</span><strong><span>访问内存数据</span></strong><span>。</span></li></ul><h3 id='53-页面置换算法-⭐'><span>5.3 页面置换算法 ⭐</span></h3><p><span>通常，把</span><strong><span>选择换出页面的算法</span></strong><span>称为</span><strong><span>页面置换算法</span></strong><span>。置换算法的好坏，将</span><strong><span>直接影响到系统的性能</span></strong><span>。</span></p><h4 id='531-最佳置换算法和先进先出置换算法'><span>5.3.1 最佳置换算法和先进先出置换算法</span></h4><p><span>1.</span><strong><span>最佳(Optimal)置换算法</span></strong><span> </span></p><p><span>最佳置换算法是一种</span><strong><span>理论上的算法</span></strong><span>。其所选择的</span><strong><span>被淘汰页面</span></strong><span>， 将是</span><strong><span>以后永不使用</span></strong><span>的，</span><strong><span>或许是在最长时间内不再被访问的页面</span></strong><span>。</span></p><p><span>由于人们目前还无法预知一个进程在内存的若干个页面 中，哪一个页面是未来最长时间内不再被访问的，因而该算法是</span><strong><span>无法实现</span></strong><span>的，但可以</span><strong><span>利用该算法去评价其它算法</span></strong><span>。</span></p><p><span>假定系统为某进程分配了三个物理块，并考虑有以下的页面号引用串： 7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1 </span></p><p><span>进程运行时，先将 7，0，1 三个页面装入内存。以后，当进程要访问页面 2 时，将会 产生缺页中断。此时 OS 根据最佳置换算法，将选择页面 7 予以淘汰。这是因为页面 0 将作 为第 5 个被访问的页面，页面 1 是第 14 个被访问的页面，而页面 7 则要在第 18 次页面访 问时才需调入。下次访问页面 0 时，因它已在内存而不必产生缺页中断。当进程访问页面 3 时，又将引起页面 1 被淘汰；因为，它在现有的 1，2，0 三个页面中，将是以后最晚才被 访问的。</span></p><p><span>由图可看出，</span><strong><span>采用最佳置换算法发 生了 6 次页面置换。</span></strong></p><p><img src="img/5-6.png" style="zoom:80%;" /></p><p>&nbsp;</p><p><span>2．</span><strong><span>先进先出(FIFO)页面置换算法</span></strong></p><p><span>该算法</span><strong><span>总是淘汰最先进入内存的页面</span></strong><span>，即选择在内存中驻 留时间最久的页面予以淘汰。</span></p><p><span>缺点：该算法</span><strong><span>与进程实际运行的规律不相适应</span></strong><span>，因为在进程中，</span><strong><span>有些页面经常被访问</span></strong><span>，FIFO 算法并</span><strong><span>不能保证这些页面不被淘汰</span></strong></p><p><span>这里，我们仍用上面的例子，但采用 FIFO 算法进行页面置换。当进程第一次 访问页面 2 时，将把第 7 页换出，因为它是最先被调入内存的；在第一次访问页面 3 时， 又将把第 0 页换出，因为它在现有的 2，0，1 三个页面中是最老的页。</span></p><p><span>由图 可以看出， 利用 </span><strong><span>FIFO 算法时进行了 12 次页面置换</span></strong><span>，</span><strong><span>比最佳置换算法正好多一倍</span></strong><span>。</span></p><p><img src="img/5-7.png" style="zoom:80%;" /></p><h4 id='532-最近最久未使用置换算法lru⭐'><span>5.3.2 最近最久未使用置换算法(LRU)⭐</span></h4><p><span>1.</span><strong><span>LRU置换算法的描述</span></strong></p><p><span>FIFO 置换算法性能之所以较差，是因为它所</span><strong><span>依据的条件是各个页面调入内存的时间</span></strong><span>， 而</span><strong><span>页面调入的先后并不能反映页面的使用情况</span></strong><span>。</span></p><p><span>⭐</span><strong><span>定义</span></strong><span>：</span><strong><span>最近最久未使用(LRU)的页面置换算法</span></strong><span>，是</span><strong><span>根据页面调入内存后的使用情况进行决策的</span></strong><span>。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的未来”的近似，</span><strong><span>因此</span></strong><span>，LRU 置换算法是</span><strong><span>选择最近最久未使用的页面予以淘汰</span></strong><span>。</span></p><p><strong><span>⭐实现：</span></strong><span>该算法</span><strong><span>赋予每个页面一个访问字段</span></strong><span>，用来</span><strong><span>记录一个页面自上次被访问以来所经历的时间 t</span></strong><span>。当须</span><strong><span>淘汰一个页面时</span></strong><span>，</span><strong><span>选择现有页面中其 t 值最大的</span></strong><span>，</span><strong><span>即最近最久 未使用的页面予以淘汰。</span></strong><span> </span></p><p><span>利用 LRU 算法对上例进行页面置换的结果如图所示。当进程第一次对页面 2 进 行访问时，由于页面 7 是最近最久未被访问的，故将它置换出去。当进程第一次对页面 3 进行访问时，第 1 页成为最近最久未使用的页，将它换出。</span></p><p><span>由图可以看出，前 5 个时间的图像与最佳置换算法时的相同，但这并非是必然的结果。因为，最佳置换算法是从“向后 看”的观点出发的，即它是依据以后各页的使用情况；而 LRU 算法则是“向前看”的，即根据各页以前的使用情况来判断，而页面过去和未来的走向之间并无必然的联系。</span></p><p><img src="img/5-8.png" style="zoom:80%;" /></p><p><span>2.</span><strong><span>LRU 置换算法的硬件支持</span></strong></p><p><span>为了解一</span><strong><span>个进程在内存中的各个页面各有多少时间未被进程访问</span></strong><span>，以及</span><strong><span>如何快速知道哪一页是最 近最久未使用的页面</span></strong><span>，须有两类硬件之一的支持：</span><strong><span>寄存器或栈</span></strong></p><p><span>（1） 寄存器 </span></p><p><span>为了</span><strong><span>记录某进程在内存中各页的使用情况</span></strong><span>，须</span><strong><span>为每个在内存中的页面</span></strong><span>配置一个</span><strong><span>移位寄存器</span></strong><span>，可表示为</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n1531" cid="n1531" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="37.6ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 16619.2 765" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.186ex;"><defs><path id="MJX-6-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path><path id="MJX-6-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-6-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-6-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-6-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-6-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-6-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-6-TEX-N-2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path><path id="MJX-6-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(1036.8,0)"><use data-c="3D" xlink:href="#MJX-6-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(2092.6,0)"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(2851.6,0)"><use data-c="1D45B" xlink:href="#MJX-6-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(3673.8,0)"><use data-c="2212" xlink:href="#MJX-6-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(4674,0)"><use data-c="31" xlink:href="#MJX-6-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(5174,0)"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(5933,0)"><use data-c="1D45B" xlink:href="#MJX-6-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(6755.2,0)"><use data-c="2212" xlink:href="#MJX-6-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(7755.4,0)"><use data-c="32" xlink:href="#MJX-6-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(8255.4,0)"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mi" transform="translate(9014.4,0)"><use data-c="1D45B" xlink:href="#MJX-6-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(9836.7,0)"><use data-c="2212" xlink:href="#MJX-6-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(10836.9,0)"><use data-c="33" xlink:href="#MJX-6-TEX-N-33"></use></g><g data-mml-node="mo" transform="translate(11503.6,0)"><use data-c="2026" xlink:href="#MJX-6-TEX-N-2026"></use></g><g data-mml-node="mi" transform="translate(12842.2,0)"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mn" transform="translate(13601.2,0)"><use data-c="32" xlink:href="#MJX-6-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(14101.2,0)"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mn" transform="translate(14860.2,0)"><use data-c="31" xlink:href="#MJX-6-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(15360.2,0)"><use data-c="1D445" xlink:href="#MJX-6-TEX-I-1D445"></use></g><g data-mml-node="mn" transform="translate(16119.2,0)"><use data-c="30" xlink:href="#MJX-6-TEX-N-30"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>R</mi><mo>=</mo><mi>R</mi><mi>n</mi><mo>−</mo><mn>1</mn><mi>R</mi><mi>n</mi><mo>−</mo><mn>2</mn><mi>R</mi><mi>n</mi><mo>−</mo><mn>3</mn><mo>…</mo><mi>R</mi><mn>2</mn><mi>R</mi><mn>1</mn><mi>R</mi><mn>0</mn></math></mjx-assistive-mml></mjx-container></div></div><p><span>当进程访问某物理块时，要</span><strong><span>将相应寄存器的 Rn－1 位置成 1</span></strong><span>。此时，定时信号将</span><strong><span>每隔一定时间将寄存器右移一位</span></strong><span>。如果我们把 n 位寄存器的数看做是一个整数，那么， 具有</span><strong><span>最小数值的寄存器所对应的页面</span></strong><span>，</span><strong><span>就是最近最久未使用的页面</span></strong><span>。</span></p><p><span>图示出了某进程 在内存中具有 8 个页面，为每个内存页面配置一个 8 位寄存器时的 LRU 访问情况。这里， 把 8 个内存页面的序号分别定为 1～8。由图可以看出，第 3 个内存页面的 </span><strong><span>R 值最小，当发生缺页时，首先将它置换出去</span></strong><span>。</span></p><p><img src="img/5-9.png" style="zoom:80%;" /></p><p><span>（2）栈</span></p><p><span>可利用一个特殊的栈来</span><strong><span>保存当前使用的各个页面的页面号</span></strong><span>。每当进程</span><strong><span>访问某页面</span></strong><span>时， 便将该页面的页面号</span><strong><span>从栈中移出</span></strong><span>，将它</span><strong><span>压入栈顶</span></strong><span>。因此，栈顶始终是最新被访问页面的编 号，而</span><strong><span>栈底则是最近最久未使用页面的页面号</span></strong><span>。</span></p><p><span>假定现有一进程所访问的页面的页面号序 列为： 4，7，0，7，1，0，1，2，1，2，6 </span></p><p><span>随着进程的访问，栈中页面号的变化情况如图所示。在访问页面 6 时发生了缺页， 此时页面 4 是最近最久未被访问的页，应将它置换出去。</span></p><p><img src="img/5-10.png" referrerpolicy="no-referrer"></p><p><span>3.</span><strong><span>最少使用置换算法LFU</span></strong></p><p><span>LFU</span><strong><span>选择在最近时期使用最少的页面作为淘汰页。</span></strong><span>LFU采用了一位寄存器方式，每次访问某页时，便</span><strong><span>将该移位寄存器的最高位置1</span></strong><span>（与LRU不同！），每隔一段时间右移一次。这样，在</span><strong><span>最近一段时间使用最少的页面是寄存器R值最小的页</span></strong><span>。</span></p><p><strong><span>与LRU的区别：</span></strong><span>这种算法不能完全反应页面的使用情况，因为在每一时间间隔内，只用寄存器一位来记录页面使用情况，因此对于同一页来说只分为有和没有，而无法反映访问频率。</span></p><h4 id='533-clock-置换算法⭐'><span>5.3.3 Clock 置换算法⭐</span></h4><p><span>LRU 算法是较好的一种算法，但</span><strong><span>由于它要求有较多的硬件支持</span></strong><span>，实际应用中大多使用LRU的近似算法。Clock算法就是一种用的较多的LRU近似算法。</span></p><p><span>1.</span><strong><span>简单的 Clock 置换算法</span></strong><span> </span></p><p><span>当采用简单 Clock 算法时，只需</span><strong><span>为每页设置一位访问位</span></strong><span>，再将</span><strong><span>内存中的所有页面</span></strong><span>都通过链接指针链接成一个</span><strong><span>循环队列</span></strong><span>。当某页被访问时，其</span><strong><span>访问位被置 1</span></strong><span>。置换算法在选择一页淘汰时，只需检查页的访问位。</span><strong><span>如果是 0，就选择该页换出</span></strong><span>；</span><strong><span>若为 1，则重新将它置 0</span></strong><span>，</span><strong><span>暂不换出</span></strong><span>，而给该页第二次驻留内存的机会，再按照 FIFO 算法检查下一个页面。当检查到队列中的</span><strong><span>最后一个页面时</span></strong><span>，若其</span><strong><span>访问位仍为 1</span></strong><span>，则再</span><strong><span>返回到队首去检查第一个页面</span></strong><span>。</span></p><p><span>由于该算法是</span><strong><span>循环地检查各页面的使用情况</span></strong><span>，故称为 Clock 算法。 但因该算法只有一位</span><strong><span>访问位</span></strong><span>，</span><strong><span>只能用它表示该页是否已经使用过</span></strong><span>，而置换时是</span><strong><span>将未使用过的页面换出去</span></strong><span>，故又把该算法称为</span><strong><span>最近未用算法 NRU</span></strong><span>(Not Recently Used)。</span></p><p><img src="img/5-11.png" style="zoom:80%;" /></p><p><span>2.</span><strong><span>改进型 Clock 置换算法</span></strong></p><p><span>在改进型 Clock 算法中，除须考虑</span><strong><span>页面的使用情况</span></strong><span>外，还要考虑</span><strong><span>置换代价</span></strong><span>。这样，选择页面换出时，</span><strong><span>既要是未使用过的页面， 又要是未被修改过的页面。</span></strong></p><p><span>由</span><strong><span>访问位 A 和修改位 M</span></strong><span> 可以组合成下面四种类型的页面： </span></p><ul><li><span>1 类(A=0，M=0)：表示该页</span><strong><span>最近既未被访问，又未被修改</span></strong><span>，是</span><strong><span>最佳淘汰页</span></strong></li><li><span>2 类(A=0，M=1)：表示该页</span><strong><span>最近未被访问，但已被修改</span></strong><span>，并不是很好的淘汰页 </span></li><li><span>3 类(A=1，M=0)：表示该页</span><strong><span>最近已被访问，但未被修改</span></strong><span>，该页有可能再被访问</span></li><li><span>4 类(A=1，M=1)：表示该页</span><strong><span>最近已被访问且被修改</span></strong><span>，该页可能再被访问</span></li></ul><p><span>在内存中的每个页必定是这四类页面之一，在进行页面置换时，可采用与简单 Clock 算法相类似的算法，其</span><strong><span>差别在于该算法须同时检查访问位与修改位</span></strong><span>，以确定该页是四类页面中的哪一种。其</span><strong><span>执行过程</span></strong><span>可分成以下三步：</span></p><ul><li><p><span>① 从指针所指示的当前位置开始，扫描循环队列，寻找 </span><strong><span>A=0 且 M=0</span></strong><span> 的第一类页面， 将所遇到的第一个页面作为所选中的淘汰页。在</span><strong><span>第一次扫描期间不改变访问位 A</span></strong><span>。 </span></p><p><span>（①失败的原因：队列中没有A=0 M=0的页面，但是有A=1,M=0,1和A=0,M=1的页面）</span></p></li><li><p><span>② 如果①失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找 </span><strong><span>A=0 且 M=1</span></strong><span> 的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，</span><strong><span>将所有扫描过的页面的访问位都置 0</span></strong><span>。 </span></p><p><span>（②失败的原因：页面中没有A=0 M=1的页面，但是有A=1 M=0的页面，②结束后A=1的页面被置为0，结束后页面类型：A=0,M=0 ）</span></p></li><li><p><span>③ 如果②也失败，亦即未找到第2类页面，则将指针返回到开始的位置，</span><strong><span>并将所有的访问位复 0</span></strong><span>。然后</span><strong><span>重复①</span></strong><span>，如果仍失败，必要时再</span><strong><span>重复②</span></strong><span>，</span><strong><span>此时就一定能找到被淘汰的页</span></strong><span>。</span></p><p><span>(①再次失败的原因，在②到③之间，可能有页面被修改了，即由A=0,M=0变成A=0,M=1；②一定能成功的原因：此时一定存在A=0,M=1的页面)</span></p></li></ul><p><span>速记：</span></p><ul><li><span>①查找00，有，淘汰，算法结束！未找到，下一步；</span></li><li><span>②查找01，有，淘汰，算法结束！未找到，下一步；(在查找过程中将A位复位为“0”)</span></li><li><span>③重复第一步</span></li></ul><p>&nbsp;</p><p><strong><span>优缺点</span></strong><span>：该算法与简单 Clock 算法比较，可</span><strong><span>减少磁盘的 I/O 操作次数</span></strong><span>。但为了找到一个可置换的 页，可能须经过几轮扫描，</span><strong><span>实现该算法本身的开销将有所增加。</span></strong></p><h4 id='534-页面缓冲算法'><span>5.3.4 页面缓冲算法</span></h4><p><span>1.</span><strong><span>影响页面换进换出效率的因素</span></strong></p><ul><li><strong><span>①页面置换算法</span></strong><span>：一个好的页面置换算法可使进程运行过程中具有较低的缺页率，从而减少换进换出的开销。</span></li><li><strong><span>②写回磁盘频率</span></strong><span>：对于已被修改的页面，换出时必须写回磁盘。写入磁盘需启动磁盘进行IO操作，这是一个不小的开销。如果能将多个页面一起写回磁盘，就可以大幅减少磁盘IO操作，减少了已修改页面换出的开销。</span></li><li><strong><span>③读入内存频率</span></strong><span>：在设置已修改换出页面链表后，当有程序访问这些页面时，直接从内存中读取，无需从磁盘中读入内存，从而减少了页面换进的开销。</span></li></ul><p><span>2.</span><strong><span>页面缓冲算法PBA</span></strong></p><p><strong><span>主要特点：</span></strong></p><p><span>① 显著降低了页面换进换出的频率，使得磁盘I/O的操作次数大幅减少，从而减少了页面换进换出的开销</span></p><p><span>② 由于换进换出的开销大幅减少，所以可以采用较简单的置换策略，如FIFO，从而无需特殊硬件支持，降低了实现的成本。</span></p><h4 id='535-访问内存的有效时间⭐'><span>5.3.5 访问内存的有效时间⭐</span></h4><p><span>与基本分页存储管理方式不同，在请求分页存储管理方式中，</span><strong><span>内存有效访问时间EAT</span></strong><span>还要考虑</span><strong><span>缺页中断的处理时间</span></strong><span>。</span></p><p><strong><span>基本分页存储管理方式</span></strong><span>：</span><strong><span>内存有效访问时间 = 访问页表时间 + 访问实际物理地址数据时间</span></strong></p><p><strong><span>请求分页存储管理方式</span></strong><span>：</span><strong><span>内存有效访问时间 = 访问页表时间  + 访问实际物理地址数据时间 + 缺页中断的处理时间</span></strong></p><p><strong><span>λ：查找快表时间</span></strong><span> </span><span>	</span><span> </span><strong><span>t：访问实际物理地址时间</span></strong><span>		</span><strong><span>ε：缺页中断处理时间</span></strong></p><p><span>（1）</span><strong><span>被访问页在内存中，对应的页表项也正在快表中（快表命中）</span></strong></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n1601" cid="n1601" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="12.937ex" height="1.805ex" role="img" focusable="false" viewBox="0 -716 5718 798" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.186ex;"><defs><path id="MJX-7-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-7-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-7-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-7-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-7-TEX-I-1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path><path id="MJX-7-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-7-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-7-TEX-I-1D438"></use></g><g data-mml-node="mi" transform="translate(764,0)"><use data-c="1D434" xlink:href="#MJX-7-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(1514,0)"><use data-c="1D447" xlink:href="#MJX-7-TEX-I-1D447"></use></g><g data-mml-node="mo" transform="translate(2495.8,0)"><use data-c="3D" xlink:href="#MJX-7-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3551.6,0)"><use data-c="1D706" xlink:href="#MJX-7-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(4356.8,0)"><use data-c="2B" xlink:href="#MJX-7-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(5357,0)"><use data-c="1D461" xlink:href="#MJX-7-TEX-I-1D461"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mi>λ</mi><mo>+</mo><mi>t</mi></math></mjx-assistive-mml></mjx-container></div></div><p><span>（2）</span><strong><span>被访问页在内存中，对应的页表项不在快表中（快表不命中）</span></strong></p><p><span>一次查找快表λ，一次读取页表t，一次更新快表λ，一次读取数据t</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n1604" cid="n1604" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="33.752ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 14918.2 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-8-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-8-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-8-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-8-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-8-TEX-I-1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path><path id="MJX-8-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-8-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-8-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-8-TEX-I-1D438"></use></g><g data-mml-node="mi" transform="translate(764,0)"><use data-c="1D434" xlink:href="#MJX-8-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(1514,0)"><use data-c="1D447" xlink:href="#MJX-8-TEX-I-1D447"></use></g><g data-mml-node="mo" transform="translate(2495.8,0)"><use data-c="3D" xlink:href="#MJX-8-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3551.6,0)"><use data-c="1D706" xlink:href="#MJX-8-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(4356.8,0)"><use data-c="2B" xlink:href="#MJX-8-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(5357,0)"><use data-c="1D461" xlink:href="#MJX-8-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(5940.2,0)"><use data-c="2B" xlink:href="#MJX-8-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(6940.4,0)"><use data-c="1D706" xlink:href="#MJX-8-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(7745.7,0)"><use data-c="2B" xlink:href="#MJX-8-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(8745.9,0)"><use data-c="1D461" xlink:href="#MJX-8-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(9384.7,0)"><use data-c="3D" xlink:href="#MJX-8-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(10440.4,0)"><use data-c="32" xlink:href="#MJX-8-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(10940.4,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="852px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(11899.4,0)"><use data-c="1D706" xlink:href="#MJX-8-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(12704.6,0)"><use data-c="2B" xlink:href="#MJX-8-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(13704.8,0)"><use data-c="1D461" xlink:href="#MJX-8-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(14065.8,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="852px" font-family="serif" font-style="italic">）</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mi>λ</mi><mo>+</mo><mi>t</mi><mo>+</mo><mi>λ</mi><mo>+</mo><mi>t</mi><mo>=</mo><mn>2</mn><mi>（</mi><mi>λ</mi><mo>+</mo><mi>t</mi><mi>）</mi></math></mjx-assistive-mml></mjx-container></div></div><p><span>（3）</span><strong><span>被访问页不在内存中（缺页） </span></strong></p><p><span>在（2）的基础上增加缺页中断处理时间</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n1607" cid="n1607" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="41.392ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 18295.1 950" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.452ex;"><defs><path id="MJX-9-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-9-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-9-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-9-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-9-TEX-I-1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path><path id="MJX-9-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-9-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-9-TEX-I-1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path><path id="MJX-9-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-9-TEX-I-1D438"></use></g><g data-mml-node="mi" transform="translate(764,0)"><use data-c="1D434" xlink:href="#MJX-9-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(1514,0)"><use data-c="1D447" xlink:href="#MJX-9-TEX-I-1D447"></use></g><g data-mml-node="mo" transform="translate(2495.8,0)"><use data-c="3D" xlink:href="#MJX-9-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3551.6,0)"><use data-c="1D706" xlink:href="#MJX-9-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(4356.8,0)"><use data-c="2B" xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(5357,0)"><use data-c="1D461" xlink:href="#MJX-9-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(5940.2,0)"><use data-c="2B" xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(6940.4,0)"><use data-c="1D700" xlink:href="#MJX-9-TEX-I-1D700"></use></g><g data-mml-node="mo" transform="translate(7628.7,0)"><use data-c="2B" xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(8628.9,0)"><use data-c="1D706" xlink:href="#MJX-9-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(9434.1,0)"><use data-c="2B" xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(10434.3,0)"><use data-c="1D461" xlink:href="#MJX-9-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(11073.1,0)"><use data-c="3D" xlink:href="#MJX-9-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(12128.9,0)"><use data-c="1D700" xlink:href="#MJX-9-TEX-I-1D700"></use></g><g data-mml-node="mo" transform="translate(12817.1,0)"><use data-c="2B" xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(13817.3,0)"><use data-c="32" xlink:href="#MJX-9-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(14317.3,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="852px" font-family="serif" font-style="italic">（</text></g><g data-mml-node="mi" transform="translate(15276.3,0)"><use data-c="1D706" xlink:href="#MJX-9-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(16081.5,0)"><use data-c="2B" xlink:href="#MJX-9-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(17081.7,0)"><use data-c="1D461" xlink:href="#MJX-9-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(17442.7,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="852px" font-family="serif" font-style="italic">）</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mi>λ</mi><mo>+</mo><mi>t</mi><mo>+</mo><mi>ε</mi><mo>+</mo><mi>λ</mi><mo>+</mo><mi>t</mi><mo>=</mo><mi>ε</mi><mo>+</mo><mn>2</mn><mi>（</mi><mi>λ</mi><mo>+</mo><mi>t</mi><mi>）</mi></math></mjx-assistive-mml></mjx-container></div></div><p><span>以上都没有考虑 </span><strong><span>快表的命中率a 和 缺页率f</span></strong><span> 等因素，加入这两个因素后</span></p><div contenteditable="false" spellcheck="false" class="mathjax-block md-end-block md-math-block md-rawblock" id="mathjax-n1609" cid="n1609" mdtype="math_block" data-math-tag-before="0" data-math-tag-after="0" data-math-labels="[]"><div class="md-rawblock-container md-math-container" tabindex="-1"><mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="66.244ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 29279.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.566ex;"><defs><path id="MJX-10-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-10-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path><path id="MJX-10-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-10-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-10-TEX-I-1D706" d="M166 673Q166 685 183 694H202Q292 691 316 644Q322 629 373 486T474 207T524 67Q531 47 537 34T546 15T551 6T555 2T556 -2T550 -11H482Q457 3 450 18T399 152L354 277L340 262Q327 246 293 207T236 141Q211 112 174 69Q123 9 111 -1T83 -12Q47 -12 47 20Q47 37 61 52T199 187Q229 216 266 252T321 306L338 322Q338 323 288 462T234 612Q214 657 183 657Q166 657 166 673Z"></path><path id="MJX-10-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-10-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path><path id="MJX-10-TEX-N-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path><path id="MJX-10-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path><path id="MJX-10-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-10-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-10-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-10-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-10-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path><path id="MJX-10-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path><path id="MJX-10-TEX-I-1D700" d="M190 -22Q124 -22 76 11T27 107Q27 174 97 232L107 239L99 248Q76 273 76 304Q76 364 144 408T290 452H302Q360 452 405 421Q428 405 428 392Q428 381 417 369T391 356Q382 356 371 365T338 383T283 392Q217 392 167 368T116 308Q116 289 133 272Q142 263 145 262T157 264Q188 278 238 278H243Q308 278 308 247Q308 206 223 206Q177 206 142 219L132 212Q68 169 68 112Q68 39 201 39Q253 39 286 49T328 72T345 94T362 105Q376 103 376 88Q376 79 365 62T334 26T275 -8T190 -22Z"></path><path id="MJX-10-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-10-TEX-I-1D438"></use></g><g data-mml-node="mi" transform="translate(764,0)"><use data-c="1D434" xlink:href="#MJX-10-TEX-I-1D434"></use></g><g data-mml-node="mi" transform="translate(1514,0)"><use data-c="1D447" xlink:href="#MJX-10-TEX-I-1D447"></use></g><g data-mml-node="mo" transform="translate(2495.8,0)"><use data-c="3D" xlink:href="#MJX-10-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3551.6,0)"><use data-c="1D706" xlink:href="#MJX-10-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(4356.8,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(5357,0)"><use data-c="1D44E" xlink:href="#MJX-10-TEX-I-1D44E"></use></g><g data-mml-node="mo" transform="translate(6108.2,0)"><use data-c="2217" xlink:href="#MJX-10-TEX-N-2217"></use></g><g data-mml-node="mi" transform="translate(6830.4,0)"><use data-c="1D461" xlink:href="#MJX-10-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(7413.7,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(8413.9,0)"><use data-c="28" xlink:href="#MJX-10-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(8802.9,0)"><use data-c="31" xlink:href="#MJX-10-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(9525.1,0)"><use data-c="2212" xlink:href="#MJX-10-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(10525.3,0)"><use data-c="1D44E" xlink:href="#MJX-10-TEX-I-1D44E"></use></g><g data-mml-node="mo" transform="translate(11054.3,0)"><use data-c="29" xlink:href="#MJX-10-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(11665.6,0)"><use data-c="2217" xlink:href="#MJX-10-TEX-N-2217"></use></g><g data-mml-node="mo" transform="translate(12387.8,0)"><use data-c="5B" xlink:href="#MJX-10-TEX-N-5B"></use></g><g data-mml-node="mi" transform="translate(12665.8,0)"><use data-c="1D461" xlink:href="#MJX-10-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(13249,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(14249.2,0)"><use data-c="1D453" xlink:href="#MJX-10-TEX-I-1D453"></use></g><g data-mml-node="mo" transform="translate(15021.4,0)"><use data-c="2217" xlink:href="#MJX-10-TEX-N-2217"></use></g><g data-mml-node="mo" transform="translate(15743.7,0)"><use data-c="28" xlink:href="#MJX-10-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(16132.7,0)"><use data-c="1D700" xlink:href="#MJX-10-TEX-I-1D700"></use></g><g data-mml-node="mo" transform="translate(16820.9,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(17821.1,0)"><use data-c="1D706" xlink:href="#MJX-10-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(18626.3,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(19626.6,0)"><use data-c="1D461" xlink:href="#MJX-10-TEX-I-1D461"></use></g><g data-mml-node="mo" transform="translate(19987.6,0)"><use data-c="29" xlink:href="#MJX-10-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(20598.8,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mo" transform="translate(21599,0)"><use data-c="28" xlink:href="#MJX-10-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(21988,0)"><use data-c="31" xlink:href="#MJX-10-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(22710.2,0)"><use data-c="2212" xlink:href="#MJX-10-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(23710.4,0)"><use data-c="1D453" xlink:href="#MJX-10-TEX-I-1D453"></use></g><g data-mml-node="mo" transform="translate(24260.4,0)"><use data-c="29" xlink:href="#MJX-10-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(24871.7,0)"><use data-c="2217" xlink:href="#MJX-10-TEX-N-2217"></use></g><g data-mml-node="mo" transform="translate(25593.9,0)"><use data-c="28" xlink:href="#MJX-10-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(25982.9,0)"><use data-c="1D706" xlink:href="#MJX-10-TEX-I-1D706"></use></g><g data-mml-node="mo" transform="translate(26788.1,0)"><use data-c="2B" xlink:href="#MJX-10-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(27788.3,0)"><use data-c="1D461" xlink:href="#MJX-10-TEX-I-1D461"></use></g><g data-mml-node="mi" transform="translate(28149.3,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="852px" font-family="serif" font-style="italic">）</text></g><g data-mml-node="mo" transform="translate(29001.7,0)"><use data-c="5D" xlink:href="#MJX-10-TEX-N-5D"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>E</mi><mi>A</mi><mi>T</mi><mo>=</mo><mi>λ</mi><mo>+</mo><mi>a</mi><mo>∗</mo><mi>t</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">[</mo><mi>t</mi><mo>+</mo><mi>f</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>ε</mi><mo>+</mo><mi>λ</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>λ</mi><mo>+</mo><mi>t</mi><mi>）</mi><mo stretchy="false">]</mo></math></mjx-assistive-mml></mjx-container></div></div><h3 id='54-抖动与工作集'><span>5.4 抖动与工作集</span></h3><h4 id='541-抖动'><span>5.4.1 抖动</span></h4><p><span>1.</span><strong><span>抖动的定义</span></strong></p><p><span>每个进程的</span><strong><span>大部分时间都用于页面的换进和换出</span></strong><span>，而</span><strong><span>几乎不能再去做任何有效的工作</span></strong><span>，从而导致发生</span><strong><span>处理机的利用率急剧下降并趋于0的情况</span></strong><span>。</span></p><p><span>2.</span><strong><span>产生抖动的原因</span></strong></p><p><span>产生抖动的根本原因是，</span><u><strong><span>同时在系统中运行的进程太多</span></strong><span>，由此分配给</span><strong><span>每个进程的物理块太少</span></strong><span>，不能满足进程正常运行的基本要求，使得每个进程在运行时</span><strong><span>频繁出现缺页</span></strong><span>，必须请求系统将所缺的页调入内存，造成在系统中排队等待页面换入换出的进程数目大幅增加。</span></u></p><h4 id='542-工作集'><span>5.4.2 工作集</span></h4><p><span>1.</span><strong><span>工作集的基本概念</span></strong></p><p><span>2.</span><strong><span>工作集的定义</span></strong></p><p><strong><span>工作集是指在某段时间间隔Δ内，进程实际所要访问页面的集合。</span></strong></p><h4 id='543-如何预防抖动'><span>5.4.3 如何预防抖动？</span></h4><ul><li><p><strong><span>采取局部置换策略</span></strong><span>：</span></p><p><span>根据局部置换策略，当进程发生缺页时，只能在分配给自己的内存空间内进行置换，不允许从其它进程去获取物理块。这样</span><strong><span>即使该进程发生了抖动</span></strong><span>，</span><strong><span>也不会影响其它进程</span></strong><span>。</span></p><p><span>缺点：当某进程发生抖动后，会长期处于磁盘IO的等待队列，延长了其它进程对磁盘的访问时间</span></p></li><li><p><strong><span>把工作集算法融入到处理机调度中</span></strong><span>：</span></p><p><span>这样，当调度程序调入作业之前，会先检查每个进程在内存的驻留页面是否足够多，如果都足够多才会调入作业，否则会为缺页率高的作业增加物理块，而不是调入新的作业。</span></p></li><li><p><strong><span>利用L=S准则调节缺页率：</span></strong></p><p><span>L是缺页的平均时间，S是平均缺页服务时间，即用于置换一个页面所需的时间。</span></p><p><span>如果L远比S大，说明很少发生缺页，磁盘能力未得到充分的利用。</span></p><p><span>如果L比S小，说明频繁发生缺页，缺页的速度已超过磁盘的处理能力。只有L与S接近时，磁盘和处理机都可达到其最大利用率。</span></p></li><li><p><strong><span>选择暂停的进程：</span></strong></p><p><span>当多道程序度偏高时，为了防止发生抖动，系统必须减少多道程序数量，此时应暂停优先级最低的进程，如果需要，再暂停优先级较低的进程。还可以暂停一个不是很重要但较大的进程，或者暂停剩余执行时间最多的进程。</span></p><p>&nbsp;</p></li></ul><h3 id='55-请求分段存储管理方式'><span>5.5 请求分段存储管理方式</span></h3><h4 id='551-请求分段中的硬件支持'><span>5.5.1 请求分段中的硬件支持</span></h4><p><span>1.</span><strong><span>段表机制</span></strong></p><p><span>在请求分段式管理中所需的主要数据结构是段表。由于在应用程序的许多段中，只有一部分段装入内存，其余的一些段仍留在外存上，故须在段表中增加若干项，以供程序在调进、调出时参考。下面给出请求分段的段表项。</span></p><p><img src="img/5-12.png" referrerpolicy="no-referrer"></p><p><span>在段表项中，除了段名(号)、段长、段在内存中的起始地址外，还增加了以下诸项。 </span></p><p><span>(1) </span><strong><span>存取方式</span></strong><span>：用于</span><strong><span>标识本分段的存取属性</span></strong><span>是只执行、只读，还是允许读/写。 </span></p><p><span>(2) </span><strong><span>访问字段 A</span></strong><span>：其含义与请求分页的相应字段相同，用于</span><strong><span>记录该段被访问的频繁程度</span></strong><span>。 </span></p><p><span>(3) </span><strong><span>修改位 M</span></strong><span>：用于</span><strong><span>表示该页在进入内存后是否已被修改过</span></strong><span>，供置换页面时参考。 </span></p><p><span>(4) </span><strong><span>存在位 P</span></strong><span>：指示</span><strong><span>本段是否已调入内存</span></strong><span>，供程序访问时参考。</span></p><p><span> (5) </span><strong><span>增补位</span></strong><span>：这是</span><strong><span>请求分段式管理</span></strong><span>中所</span><strong><span>特有</span></strong><span>的字段，用于</span><strong><span>表示本段在运行过程中是否做过动态增长</span></strong></p><p><span> (6) </span><strong><span>外存始址</span></strong><span>：指示本段在外存中的起始地址，即起始盘块号。</span></p><p><span>2.缺段中断机构</span></p><p><span>在请求分段系统中，每当发现运行进程所要访问的段尚未调入内存时，便由缺段中断机构产生一缺段中断信号，进入 OS 后由缺段中断处理程序将所需的段调入内存。缺段中断机 构与缺页中断机构类似，它同样需要在一条指令的执行期间，产生和处理中断，以及在一条 指令执行期间，可能产生多次缺段中断。但由于分段是信息的逻辑单位，因而</span><strong><span>不可能出现一条指令被分割在两个分段</span></strong><span>中和</span><strong><span>一组信息被分割在两个分段中</span></strong><span>的情况。由于段不是定长的，这使对缺段中断的处理要比对缺页中断的处理复杂。</span></p><p><img src="img/5-13.png" style="zoom:80%;" /></p><p><span>3.地址变换机构</span></p><p><span>请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，所以在地址变换时，若发现所要访问的段不在内存，必须先将所缺的段调入内存，并修改段表，然后才能再利用段表进行地址变换。为此，在地址变换机构中又增加了某些功能，如</span><strong><span>缺段中断的请求及处理</span></strong><span>等。</span></p><p><img src="img/5-14.png" referrerpolicy="no-referrer"></p><h4 id='552-分段的共享与保护'><span>5.5.2 分段的共享与保护</span></h4><p><span>1.共享段表</span></p><p><span>为了实现分段共享，可在系统中配置一张共享段表，所有各</span><strong><span>共享段</span></strong><span>都在共享段表中</span><strong><span>占有一表项</span></strong><span>。</span></p><p><span>(1) </span><strong><span>共享进程计数 count</span></strong><span>。</span><strong><span>共享段</span></strong><span>是为</span><strong><span>多个进程所需要</span></strong><span>的，当某进程不再需要而释放它时，系统</span><strong><span>并不回收该段所占内存区</span></strong><span>，</span><strong><span>仅当所有共享该段的进程全都不再需要</span></strong><span>它时，才由系统回收该段所占内存区。为了</span><strong><span>记录有多少个进程需要共享该分段</span></strong><span>， 特设置了一个整型变量 count。</span></p><p><span>(2) </span><strong><span>存取控制字段</span></strong><span>。一个共享段，应给</span><strong><span>不同的进程以不同的存取权限</span></strong><span>。如，对于文件主，通常允许读和写；而对其它进程，则可能只允许读，甚至只允许执行。</span></p><p><span>(3) </span><strong><span>段号</span></strong><span>。对于一个共享段，</span><strong><span>不同的进程可以各用不同的段号去共享该段</span></strong><span>。</span></p><p><img src="img/5-15.png" referrerpolicy="no-referrer"></p><p><span>2.共享段的分配与回收</span></p><p><span>（1）共享段的分配：在为共享段分配内存时，对</span><strong><span>第一个请求使用该共享段的进程</span></strong><span>，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址</span><strong><span>填入请求进程的段表</span></strong><span>的相应项中，还须在共享段表中增加一表项，填写有关数据，把 count 置为 1；之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分 配内存，而只需在调用进程的段表中增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行 count :=count+1 操作，以表明有两 个进程共享该段。 </span></p><p><span>（2）共享段的回收：当共享此段的某进程不再需要该段时，应将该段释放，包括</span><strong><span>撤消在该进程段表中共享段所对应的表项</span></strong><span>，以及执行 count = count-1 操作。若</span><strong><span>结果为 0</span></strong><span>，则须</span><strong><span>由系统回收该共享段的物理内存</span></strong><span>，以及</span><strong><span>取消在共享段表</span></strong><span>中该段所对应的</span><strong><span>表项</span></strong><span>，表明此时已没有进程使用该段。</span></p><p><span>3.分段保护</span></p><p><span>（1）越界检查：进行存储访问时，首先将</span><strong><span>逻辑地址空间的段号</span></strong><span>与</span><strong><span>段表长度进行比较</span></strong><span>，如果</span><strong><span>段号大于等于段表长度</span></strong><span>，将发出</span><strong><span>地址越界中断</span></strong><span>信号；其次，还要检查</span><strong><span>段内地址是否等于或大于段长</span></strong><span>，若大于段长，将产生</span><strong><span>地址越界中断</span></strong><span>信号，从而保证了</span><strong><span>每个进程只能在自己的地址空间内运行</span></strong><span>。 </span></p><p><span>（2）存取控制检查：在段表的每个表项中，都设置了一个“存取控制”字段，用于规定对该段的访问方式。 对于共享段而言，存取控制就显得尤为重要，因而对不同的进程，应赋予不同的读写权限。这时，既要保证信息的安全性，又要满足运行需要。</span></p><p>&nbsp;</p><h2 id='6输入输出系统'><span>6.输入输出系统</span></h2><h3 id='63-中断机构和中断处理程序⭐'><span>6.3 中断机构和中断处理程序⭐</span></h3><h4 id='631-中断简介'><span>6.3.1 中断简介</span></h4><p><strong><span>1.⭐什么是中断？</span></strong></p><p><span>中断是指CPU对I/O设备发来的中断信号的一组响应。CPU暂停正在执行的程序，保留CPU环境后，自动的执行该I/O设备的中断处理程序。执行完毕后再回到断电继续执行原来的程序。也被称为外中断。</span></p><p><span>2.什么是陷入？</span></p><p><span>陷入是由CPU内部事件引起的中断，也被称为内中断。例如进程在运算中发送了上溢或下溢、程序出错和地址越界等。当系统发现陷入事件时，CPU页会暂停执行当前程序，转去执行该陷入事件的处理程序。</span></p><p><span>3.中断和陷入有什么区别？</span></p><p><span>主要区别是信号的来源，引起中断的信号来自CPU外部，引起陷入的信号来自CPU内部。</span></p><p><span>4.中断向量表</span></p><p><span>为了处理上的方便，通常把中断处理程序的入口地址放在中断向量表的表项中，并为每个设备的中断请求规定一个中断号，对应表中的一个表项。</span></p><p><span>当I/O设备发来中断请求时，由中断控制器确定该请求中断号，根据中断号查找中断向量表，获得中断处理程序的入口地址，然后转入中断处理程序执行。</span></p><p><span>5.中断优先级</span></p><p><span>经常会有多个中断信号源，每个中断源对服务要求的紧急程度不同。为此，系统需要为它们规定不同的优先级</span></p><p><span>6.对多中断源的处理方式</span></p><p><span>两种处理方式：屏蔽中断和嵌套中断</span></p><p><span>（1）屏蔽中断</span></p><p><span>当处理机正在处理一个字段时，将屏蔽所有字段，即处理机暂时不接受任何新到的中断请求，直到处理机完成当前的中断处理，然后检查有无中断发生。若有，再去处理新到的字段，若无，则返回被中断的程序。</span></p><p><span>优点：实现简单，所有字段都按顺序依次处理</span></p><p><span>缺点：不能用于对实时性要求较高的字段请求</span></p><p><span>（2）嵌套中断</span></p><p><span>在设置了中断优先级的系统中，通常这样来进行优先级控制：</span></p><ul><li><span>① 当同时有多个不同优先级的中断请求时，CPU优先响应最高优先级的中断请求</span></li><li><span>② 高优先级的中断请求可以抢占正在运行的低优先级中断的处理机。当高优先级的中断请求执行完成后，再执行原来的中断请求程序。</span></li></ul><h4 id='632-中断处理程序'><span>6.3.2 中断处理程序</span></h4><p><span>⭐</span><strong><span>中断处理程序的处理过程：</span></strong></p><p><strong><span>（1）测定是否有未响应的中断信号。</span></strong></p><p><strong><span>（2）保护被中断进程的CPU环境。</span></strong></p><p><strong><span>（3）转入相应的设备处理程序</span></strong><span>。由处理机对各个中断源进行测试，确定引起本次中断的I/O设备，并向发出中断信号的设备发送部分确认信号。该设备收到确认信号后，立即取消发出的中断请求信号，然后将相应的设备中断处理程序的入口地址装入程序计时器中，这样处理机就能自动转向中断处理程序。</span></p><p><strong><span>（4）中断处理。</span></strong><span>中断处理程序首先从设备控制器中读出设备状态，判断本次中断是正常完成中断还是异常结束中断，若是前者，中断处理程序便结束处理。若是异常结束中断，则根据异常原因做相应处理。</span></p><p><strong><span>（5）恢复CPU的现场并退出中断</span></strong><span>。</span></p><p>&nbsp;</p><h2 id='9操作系统接口'><span>9.操作系统接口</span></h2><h3 id='94-系统调用的概念和类型'><span>9.4 系统调用的概念和类型</span></h3><h4 id='941-系统调用的基本概念'><span>9.4.1 系统调用的基本概念 </span></h4><p><span>1.</span><strong><span>系统态和用户态</span></strong></p><p><span>计算机系统设置两种状态：系统态和用户态。在实际运行时，处理机会在系统态和用户态间切换。相应的，OS将CPU的指令集分为特权指令和非特权指令：</span></p><p><span>（1）特权指令。指在系统态中运行的指令，它对内存空间的访问和访问范围基本不受限制。</span><strong><span>特权指令只允许OS使用</span></strong><span>，不允许应用程序使用。</span></p><p><span>（2）非特权指令。指在用户态允许的指令，它只能完成一般性的操作和任务，不能对系统的硬件和软件直接进行访问，对内存访问范围局限于用户空间。这样可以防止应用程序的运行异常对系统造成破坏。</span></p><p><span>2.</span><strong><span>系统调用</span></strong></p><p><span>提供系统调用的目的：使应用程序可以通过它间接调用OS的相关过程，取得相应的服务。</span></p><p><span>系统调用的实质：应用程序请求OS内核完成某功能的一种过程调用，但它是一组特殊的过程调用。</span></p><p><strong><span>系统调用与一般过程调用的区别：</span></strong></p><p><span>① 运行在不同的系统状态。系统调用的调用程序运行在用户态，被调用程序运行在系统态。而一般过程调用的二者都运行在系统态或用户态。</span></p><p><span>② 状态的转换。一般的过程调用不涉及系统状态的转换。系统调用用于调用和被调用程序运行在不同的系统状态，所以调用程序的状态要先转为系统态再转向相应的系统调用处理子程序。</span></p><p><span>③ 返回问题。抢占式调度方式</span><span>	</span><span>被调用过程执行完</span><span>	</span><span>重新分析优先级</span><span>	</span><span>调用进程最高-&gt;继续执行</span><span>	</span><span>否则引起重新调度</span></p><p><span>④ 嵌套调用。系统调用和一般过程调用都可以进行嵌套调用。在被调用过程执行时，可以调用另一个系统调用。</span></p><h4 id='942-系统调用的类型'><span>9.4.2 系统调用的类型</span></h4><p><span>1.进程控制类系统调用</span></p><p><span>2.文件操作类系统调用</span></p><p><span>3.进程通信类系统调用</span></p><p>&nbsp;</p></div></div>
</body>
</html>